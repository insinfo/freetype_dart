// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

class NativeLibrary {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  NativeLibrary(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  NativeLibrary.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  /// /
  /// /*************************************************************************/
  /// /
  int FT_Init_FreeType(
    ffi.Pointer<FT_Library> library1,
  ) {
    return _FT_Init_FreeType(
      library1,
    );
  }

  late final _FT_Init_FreeTypePtr =
      _lookup<ffi.NativeFunction<FT_Error Function(ffi.Pointer<FT_Library>)>>(
          'FT_Init_FreeType');
  late final _FT_Init_FreeType =
      _FT_Init_FreeTypePtr.asFunction<int Function(ffi.Pointer<FT_Library>)>();

  /// /
  int FT_Done_FreeType(
    FT_Library library1,
  ) {
    return _FT_Done_FreeType(
      library1,
    );
  }

  late final _FT_Done_FreeTypePtr =
      _lookup<ffi.NativeFunction<FT_Error Function(FT_Library)>>(
          'FT_Done_FreeType');
  late final _FT_Done_FreeType =
      _FT_Done_FreeTypePtr.asFunction<int Function(FT_Library)>();

  /// /
  int FT_New_Face(
    FT_Library library1,
    ffi.Pointer<ffi.Char> filepathname,
    int face_index,
    ffi.Pointer<FT_Face> face,
  ) {
    return _FT_New_Face(
      library1,
      filepathname,
      face_index,
      face,
    );
  }

  late final _FT_New_FacePtr = _lookup<
      ffi.NativeFunction<
          FT_Error Function(FT_Library, ffi.Pointer<ffi.Char>, FT_Long,
              ffi.Pointer<FT_Face>)>>('FT_New_Face');
  late final _FT_New_Face = _FT_New_FacePtr.asFunction<
      int Function(
          FT_Library, ffi.Pointer<ffi.Char>, int, ffi.Pointer<FT_Face>)>();

  int FT_Open_Face(
    FT_Library library1,
    FT_Stream stream,
    int face_index,
    ffi.Pointer<FT_Face> face,
  ) {
    return _FT_Open_Face(
      library1,
      stream,
      face_index,
      face,
    );
  }

  late final _FT_Open_FacePtr = _lookup<
      ffi.NativeFunction<
          FT_Error Function(FT_Library, FT_Stream, FT_Long,
              ffi.Pointer<FT_Face>)>>('FT_Open_Face');
  late final _FT_Open_Face = _FT_Open_FacePtr.asFunction<
      int Function(FT_Library, FT_Stream, int, ffi.Pointer<FT_Face>)>();

  int FT_New_Memory_Face(
    FT_Library library1,
    ffi.Pointer<ffi.Void> file_base,
    int file_size,
    int face_index,
    ffi.Pointer<FT_Face> face,
  ) {
    return _FT_New_Memory_Face(
      library1,
      file_base,
      file_size,
      face_index,
      face,
    );
  }

  late final _FT_New_Memory_FacePtr = _lookup<
      ffi.NativeFunction<
          FT_Error Function(FT_Library, ffi.Pointer<ffi.Void>, FT_Long, FT_Long,
              ffi.Pointer<FT_Face>)>>('FT_New_Memory_Face');
  late final _FT_New_Memory_Face = _FT_New_Memory_FacePtr.asFunction<
      int Function(
          FT_Library, ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<FT_Face>)>();

  /// /
  int FT_Done_Face(
    FT_Face face,
  ) {
    return _FT_Done_Face(
      face,
    );
  }

  late final _FT_Done_FacePtr =
      _lookup<ffi.NativeFunction<FT_Error Function(FT_Face)>>('FT_Done_Face');
  late final _FT_Done_Face =
      _FT_Done_FacePtr.asFunction<int Function(FT_Face)>();

  /// /
  int FT_New_Size(
    FT_Face face,
    ffi.Pointer<FT_Size> size,
  ) {
    return _FT_New_Size(
      face,
      size,
    );
  }

  late final _FT_New_SizePtr = _lookup<
          ffi.NativeFunction<FT_Error Function(FT_Face, ffi.Pointer<FT_Size>)>>(
      'FT_New_Size');
  late final _FT_New_Size =
      _FT_New_SizePtr.asFunction<int Function(FT_Face, ffi.Pointer<FT_Size>)>();

  /// /
  int FT_Done_Size(
    FT_Size size,
  ) {
    return _FT_Done_Size(
      size,
    );
  }

  late final _FT_Done_SizePtr =
      _lookup<ffi.NativeFunction<FT_Error Function(FT_Size)>>('FT_Done_Size');
  late final _FT_Done_Size =
      _FT_Done_SizePtr.asFunction<int Function(FT_Size)>();

  /// /
  int FT_Set_Char_Size(
    FT_Face face,
    int char_width,
    int char_height,
    int horz_resolution,
    int vert_resolution,
  ) {
    return _FT_Set_Char_Size(
      face,
      char_width,
      char_height,
      horz_resolution,
      vert_resolution,
    );
  }

  late final _FT_Set_Char_SizePtr = _lookup<
      ffi.NativeFunction<
          FT_Error Function(FT_Face, FT_F26Dot6, FT_F26Dot6, FT_UInt,
              FT_UInt)>>('FT_Set_Char_Size');
  late final _FT_Set_Char_Size = _FT_Set_Char_SizePtr.asFunction<
      int Function(FT_Face, int, int, int, int)>();

  /// /
  int FT_Set_Pixel_Sizes(
    FT_Face face,
    int pixel_width,
    int pixel_height,
  ) {
    return _FT_Set_Pixel_Sizes(
      face,
      pixel_width,
      pixel_height,
    );
  }

  late final _FT_Set_Pixel_SizesPtr =
      _lookup<ffi.NativeFunction<FT_Error Function(FT_Face, FT_UInt, FT_UInt)>>(
          'FT_Set_Pixel_Sizes');
  late final _FT_Set_Pixel_Sizes =
      _FT_Set_Pixel_SizesPtr.asFunction<int Function(FT_Face, int, int)>();

  /// /
  int FT_New_GlyphSlot(
    FT_Face face,
    ffi.Pointer<FT_GlyphSlot> aslot,
  ) {
    return _FT_New_GlyphSlot(
      face,
      aslot,
    );
  }

  late final _FT_New_GlyphSlotPtr = _lookup<
      ffi.NativeFunction<
          FT_Error Function(
              FT_Face, ffi.Pointer<FT_GlyphSlot>)>>('FT_New_GlyphSlot');
  late final _FT_New_GlyphSlot = _FT_New_GlyphSlotPtr.asFunction<
      int Function(FT_Face, ffi.Pointer<FT_GlyphSlot>)>();

  /// /
  void FT_Done_GlyphSlot(
    FT_GlyphSlot slot,
  ) {
    return _FT_Done_GlyphSlot(
      slot,
    );
  }

  late final _FT_Done_GlyphSlotPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(FT_GlyphSlot)>>(
          'FT_Done_GlyphSlot');
  late final _FT_Done_GlyphSlot =
      _FT_Done_GlyphSlotPtr.asFunction<void Function(FT_GlyphSlot)>();

  /// /
  int FT_Load_Glyph(
    FT_Face face,
    int glyph_index,
    int load_flags,
  ) {
    return _FT_Load_Glyph(
      face,
      glyph_index,
      load_flags,
    );
  }

  late final _FT_Load_GlyphPtr =
      _lookup<ffi.NativeFunction<FT_Error Function(FT_Face, FT_UInt, FT_Int)>>(
          'FT_Load_Glyph');
  late final _FT_Load_Glyph =
      _FT_Load_GlyphPtr.asFunction<int Function(FT_Face, int, int)>();

  /// /
  int FT_Load_Char(
    FT_Face face,
    int char_code,
    int load_flags,
  ) {
    return _FT_Load_Char(
      face,
      char_code,
      load_flags,
    );
  }

  late final _FT_Load_CharPtr =
      _lookup<ffi.NativeFunction<FT_Error Function(FT_Face, FT_ULong, FT_Int)>>(
          'FT_Load_Char');
  late final _FT_Load_Char =
      _FT_Load_CharPtr.asFunction<int Function(FT_Face, int, int)>();

  /// /
  int FT_Get_Glyph_Bitmap(
    FT_Face face,
    ffi.Pointer<FT_Bitmap> map,
  ) {
    return _FT_Get_Glyph_Bitmap(
      face,
      map,
    );
  }

  late final _FT_Get_Glyph_BitmapPtr = _lookup<
          ffi
          .NativeFunction<FT_Error Function(FT_Face, ffi.Pointer<FT_Bitmap>)>>(
      'FT_Get_Glyph_Bitmap');
  late final _FT_Get_Glyph_Bitmap = _FT_Get_Glyph_BitmapPtr.asFunction<
      int Function(FT_Face, ffi.Pointer<FT_Bitmap>)>();

  /// /
  int FT_Get_Kerning(
    FT_Face face,
    int left_glyph,
    int right_glyph,
    ffi.Pointer<FT_Vector> kerning,
  ) {
    return _FT_Get_Kerning(
      face,
      left_glyph,
      right_glyph,
      kerning,
    );
  }

  late final _FT_Get_KerningPtr = _lookup<
      ffi.NativeFunction<
          FT_Error Function(FT_Face, FT_UInt, FT_UInt,
              ffi.Pointer<FT_Vector>)>>('FT_Get_Kerning');
  late final _FT_Get_Kerning = _FT_Get_KerningPtr.asFunction<
      int Function(FT_Face, int, int, ffi.Pointer<FT_Vector>)>();

  /// /
  int FT_Get_Char_Index(
    FT_Face face,
    int charcode,
  ) {
    return _FT_Get_Char_Index(
      face,
      charcode,
    );
  }

  late final _FT_Get_Char_IndexPtr =
      _lookup<ffi.NativeFunction<FT_UInt Function(FT_Face, FT_ULong)>>(
          'FT_Get_Char_Index');
  late final _FT_Get_Char_Index =
      _FT_Get_Char_IndexPtr.asFunction<int Function(FT_Face, int)>();

  /// /
  int FT_MulDiv(
    int a,
    int b,
    int c,
  ) {
    return _FT_MulDiv(
      a,
      b,
      c,
    );
  }

  late final _FT_MulDivPtr =
      _lookup<ffi.NativeFunction<FT_Long Function(FT_Long, FT_Long, FT_Long)>>(
          'FT_MulDiv');
  late final _FT_MulDiv =
      _FT_MulDivPtr.asFunction<int Function(int, int, int)>();

  int FT_MulFix(
    int a,
    int b,
  ) {
    return _FT_MulFix(
      a,
      b,
    );
  }

  late final _FT_MulFixPtr =
      _lookup<ffi.NativeFunction<FT_Long Function(FT_Long, FT_Long)>>(
          'FT_MulFix');
  late final _FT_MulFix = _FT_MulFixPtr.asFunction<int Function(int, int)>();

  /// /
  int FT_DivFix(
    int a,
    int b,
  ) {
    return _FT_DivFix(
      a,
      b,
    );
  }

  late final _FT_DivFixPtr =
      _lookup<ffi.NativeFunction<FT_Long Function(FT_Long, FT_Long)>>(
          'FT_DivFix');
  late final _FT_DivFix = _FT_DivFixPtr.asFunction<int Function(int, int)>();

  /// /
  int FT_Decompose_Outline(
    ffi.Pointer<FT_Outline> outline,
    ffi.Pointer<FT_Outline_Funcs> interface1,
    ffi.Pointer<ffi.Void> user,
  ) {
    return _FT_Decompose_Outline(
      outline,
      interface1,
      user,
    );
  }

  late final _FT_Decompose_OutlinePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<FT_Outline>,
              ffi.Pointer<FT_Outline_Funcs>,
              ffi.Pointer<ffi.Void>)>>('FT_Decompose_Outline');
  late final _FT_Decompose_Outline = _FT_Decompose_OutlinePtr.asFunction<
      int Function(ffi.Pointer<FT_Outline>, ffi.Pointer<FT_Outline_Funcs>,
          ffi.Pointer<ffi.Void>)>();

  /// /
  int FT_New_Outline(
    FT_Library library1,
    int numPoints,
    int numContours,
    ffi.Pointer<FT_Outline> outline,
  ) {
    return _FT_New_Outline(
      library1,
      numPoints,
      numContours,
      outline,
    );
  }

  late final _FT_New_OutlinePtr = _lookup<
      ffi.NativeFunction<
          FT_Error Function(FT_Library, FT_UInt, FT_Int,
              ffi.Pointer<FT_Outline>)>>('FT_New_Outline');
  late final _FT_New_Outline = _FT_New_OutlinePtr.asFunction<
      int Function(FT_Library, int, int, ffi.Pointer<FT_Outline>)>();

  /// /
  int FT_Done_Outline(
    FT_Library library1,
    ffi.Pointer<FT_Outline> outline,
  ) {
    return _FT_Done_Outline(
      library1,
      outline,
    );
  }

  late final _FT_Done_OutlinePtr = _lookup<
      ffi.NativeFunction<
          FT_Error Function(
              FT_Library, ffi.Pointer<FT_Outline>)>>('FT_Done_Outline');
  late final _FT_Done_Outline = _FT_Done_OutlinePtr.asFunction<
      int Function(FT_Library, ffi.Pointer<FT_Outline>)>();

  /// /
  int FT_Get_Outline_CBox(
    ffi.Pointer<FT_Outline> outline,
    ffi.Pointer<FT_BBox> cbox,
  ) {
    return _FT_Get_Outline_CBox(
      outline,
      cbox,
    );
  }

  late final _FT_Get_Outline_CBoxPtr = _lookup<
      ffi.NativeFunction<
          FT_Error Function(ffi.Pointer<FT_Outline>,
              ffi.Pointer<FT_BBox>)>>('FT_Get_Outline_CBox');
  late final _FT_Get_Outline_CBox = _FT_Get_Outline_CBoxPtr.asFunction<
      int Function(ffi.Pointer<FT_Outline>, ffi.Pointer<FT_BBox>)>();

  /// /
  void FT_Translate_Outline(
    ffi.Pointer<FT_Outline> outline,
    int xOffset,
    int yOffset,
  ) {
    return _FT_Translate_Outline(
      outline,
      xOffset,
      yOffset,
    );
  }

  late final _FT_Translate_OutlinePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<FT_Outline>, FT_Pos,
              FT_Pos)>>('FT_Translate_Outline');
  late final _FT_Translate_Outline = _FT_Translate_OutlinePtr.asFunction<
      void Function(ffi.Pointer<FT_Outline>, int, int)>();

  /// /
  int FT_Set_Raster(
    FT_Library library1,
    ffi.Pointer<FT_Raster_Interface> interface1,
    FT_Raster raster,
  ) {
    return _FT_Set_Raster(
      library1,
      interface1,
      raster,
    );
  }

  late final _FT_Set_RasterPtr = _lookup<
      ffi.NativeFunction<
          FT_Error Function(FT_Library, ffi.Pointer<FT_Raster_Interface>,
              FT_Raster)>>('FT_Set_Raster');
  late final _FT_Set_Raster = _FT_Set_RasterPtr.asFunction<
      int Function(FT_Library, ffi.Pointer<FT_Raster_Interface>, FT_Raster)>();

  /// /
  int FT_Set_Raster_Mode(
    FT_Library library1,
    int format,
    ffi.Pointer<ffi.Char> mode,
    ffi.Pointer<ffi.Char> args,
  ) {
    return _FT_Set_Raster_Mode(
      library1,
      format,
      mode,
      args,
    );
  }

  late final _FT_Set_Raster_ModePtr = _lookup<
      ffi.NativeFunction<
          FT_Error Function(FT_Library, ffi.Int32, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('FT_Set_Raster_Mode');
  late final _FT_Set_Raster_Mode = _FT_Set_Raster_ModePtr.asFunction<
      int Function(
          FT_Library, int, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();
}

final class FT_MemoryRec_ extends ffi.Struct {
  external ffi.Pointer<ffi.Void> user;

  external FT_Alloc_Func alloc;

  external FT_Free_Func free;

  external FT_Realloc_Func realloc;
}

typedef FT_Alloc_Func = ffi.Pointer<ffi.NativeFunction<FT_Alloc_FuncFunction>>;
typedef FT_Alloc_FuncFunction = ffi.Pointer<ffi.Void> Function(
    FT_Memory memory, ffi.Long size);
typedef DartFT_Alloc_FuncFunction = ffi.Pointer<ffi.Void> Function(
    FT_Memory memory, int size);

/// M E M O R Y   M A N A G E M E N T
typedef FT_Memory = ffi.Pointer<FT_MemoryRec_>;
typedef FT_Free_Func = ffi.Pointer<ffi.NativeFunction<FT_Free_FuncFunction>>;
typedef FT_Free_FuncFunction = ffi.Void Function(
    FT_Memory memory, ffi.Pointer<ffi.Void> block);
typedef DartFT_Free_FuncFunction = void Function(
    FT_Memory memory, ffi.Pointer<ffi.Void> block);
typedef FT_Realloc_Func
    = ffi.Pointer<ffi.NativeFunction<FT_Realloc_FuncFunction>>;
typedef FT_Realloc_FuncFunction = ffi.Pointer<ffi.Void> Function(
    FT_Memory memory,
    ffi.Long cur_size,
    ffi.Long new_size,
    ffi.Pointer<ffi.Void> block);
typedef DartFT_Realloc_FuncFunction = ffi.Pointer<ffi.Void> Function(
    FT_Memory memory, int cur_size, int new_size, ffi.Pointer<ffi.Void> block);

/// I / O   M A N A G E M E N T
final class FT_StreamDesc_ extends ffi.Union {
  @ffi.Long()
  external int value;

  external ffi.Pointer<ffi.Void> pointer;
}

final class FT_StreamRec_ extends ffi.Struct {
  external ffi.Pointer<ffi.Char> base;

  @ffi.UnsignedLong()
  external int size;

  @ffi.UnsignedLong()
  external int pos;

  external FT_StreamDesc descriptor;

  external FT_StreamDesc pathname;

  external FT_Stream_IO read;

  external FT_Stream_Close close;

  external FT_Memory memory;

  external ffi.Pointer<ffi.Char> cursor;

  external ffi.Pointer<ffi.Char> limit;
}

/// I / O   M A N A G E M E N T
typedef FT_StreamDesc = FT_StreamDesc_;
typedef FT_Stream_IO = ffi.Pointer<ffi.NativeFunction<FT_Stream_IOFunction>>;
typedef FT_Stream_IOFunction = ffi.UnsignedLong Function(
    FT_Stream stream,
    ffi.UnsignedLong offset,
    ffi.Pointer<ffi.Char> buffer,
    ffi.UnsignedLong count);
typedef DartFT_Stream_IOFunction = int Function(
    FT_Stream stream, int offset, ffi.Pointer<ffi.Char> buffer, int count);
typedef FT_Stream = ffi.Pointer<FT_StreamRec_>;
typedef FT_Stream_Close
    = ffi.Pointer<ffi.NativeFunction<FT_Stream_CloseFunction>>;
typedef FT_Stream_CloseFunction = ffi.Void Function(FT_Stream stream);
typedef DartFT_Stream_CloseFunction = void Function(FT_Stream stream);

final class FT_Vector_ extends ffi.Struct {
  @FT_Pos()
  external int x;

  @FT_Pos()
  external int y;
}

/// /
typedef FT_Pos = ffi.Long;
typedef DartFT_Pos = int;

/// <Enum>
/// FT_Pixel_Mode
///
/// <Description>
/// An enumeration type used to describe the format of pixels
/// in a given bitmap. Note that additional formats may be added
/// in the future.
///
/// <Fields>
/// ft_pixel_mode_mono   :: a monochrome bitmap (1 bit/pixel)
///
/// ft_pixel_mode_grays  :: an 8-bit gray-levels bitmap. Note that
/// the total number of gray levels is given
/// in the `num_grays' field of the FT_Bitmap
/// structure.
///
/// ft_pixel_mode_pal2   :: a 2-bit paletted bitmap.
/// currently unused by FreeType.
///
/// ft_pixel_mode_pal4   :: a 4-bit paletted bitmap.
/// currently unused by FreeType.
///
/// ft_pixel_mode_pal8   :: an 8-bit paletted bitmap.
/// currently unused by FreeType.
///
/// ft_pixel_mode_rgb15  :: a 15-bit RGB bitmap. Uses 5:5:5 encoding
/// currently unused by FreeType.
///
/// ft_pixel_mode_rgb16  :: a 16-bit RGB bitmap. Uses 5:6:5 encoding
/// currently unused by FreeType.
///
/// ft_pixel_mode_rgb24  :: a 24-bit RGB bitmap.
/// currently unused by FreeType.
///
/// ft_pixel_mode_rgb32  :: a 32-bit RGB bitmap.
/// currently unused by FreeType.
///
/// <Note>
/// Some anti-aliased bitmaps might be embedded in TrueType fonts
/// using formats pal2 or pal4, though no fonts presenting those
/// have been found to date..
abstract class FT_Pixel_Mode_ {
  static const int ft_pixel_mode_none = 0;
  static const int ft_pixel_mode_mono = 1;
  static const int ft_pixel_mode_grays = 2;
  static const int ft_pixel_mode_pal2 = 3;
  static const int ft_pixel_mode_pal4 = 4;
  static const int ft_pixel_mode_pal8 = 5;
  static const int ft_pixel_mode_rgb15 = 6;
  static const int ft_pixel_mode_rgb16 = 7;
  static const int ft_pixel_mode_rgb24 = 8;
  static const int ft_pixel_mode_rgb32 = 9;
  static const int ft_pixel_mode_max = 10;
}

/// <Enum>
/// FT_Palette_Mode
///
/// <Description>
/// An enumeration type used to describe the format of a bitmap
/// palette, used with ft_pixel_mode_pal4 and ft_pixel_mode_pal8
///
/// <Fields>
/// ft_palette_mode_rgb  :: the palette is an array of 3-bytes RGB records
///
/// ft_palette_mode_rgba :: the palette is an array of 4-bytes RGBA records
///
/// <Note>
/// As ft_pixel_mode_pal2, pal4 and pal8 are currently unused by
/// FreeType, these types are not handled by the library itself.
abstract class FT_Palette_Mode_ {
  static const int ft_palette_mode_rgb = 0;
  static const int ft_palette_mode_rgba = 1;
  static const int ft_palettte_mode_max = 2;
}

/// <Struct>
/// FT_Bitmap
///
/// <Description>
/// A structure used to describe a bitmap or pixmap to the raster.
/// Note that we now manage pixmaps of various depths through the
/// `pixel_mode' field.
///
/// <Fields>
/// rows         :: The number of bitmap rows.
///
/// width        :: The number of pixels in bitmap row.
///
/// pitch        :: The pitch's absolute value is the number of bytes
/// taken by one bitmap row, including padding. However,
/// the pitch is positive when the bitmap has a `down'
/// flow, and negative when it has an `up' flow. In all
/// cases, the pitch is an offset to add to a bitmap
/// pointer in order to go down one row.
///
/// buffer       :: A typeless pointer to the bitmap buffer. This value
/// should be aligned on 32-bit boundaries in most cases.
///
/// num_grays    :: this field is only used with ft_pixel_mode_grays,
/// it gives the number of gray levels used in the
/// bitmap.
///
/// pixel_mode   :: the pixel_mode, i.e. how pixel bits are stored
///
/// palette_mode :: this field is only used with paletted pixel modes,
/// it indicates how the palette is stored
///
/// palette      :: a typeless pointer to the bitmap palette. only used
/// for paletted pixel modes.
///
/// <Note>
/// When using pixel modes pal2, pal4 and pal8 with a void `palette'
/// field, a gray pixmap with respectively 4, 16 and 256 levels of gray
/// is assumed. This, in order to be compatible with some embedded bitmap
/// formats defined in the TrueType spec.
///
/// Note that no font was found presenting such embedded bitmaps, so this
/// is currently completely unhandled by the library.
final class FT_Bitmap_ extends ffi.Struct {
  @ffi.Int()
  external int rows;

  @ffi.Int()
  external int width;

  @ffi.Int()
  external int pitch;

  external ffi.Pointer<ffi.Void> buffer;

  @ffi.Short()
  external int num_grays;

  @ffi.Char()
  external int pixel_mode;

  @ffi.Char()
  external int palette_mode;

  external ffi.Pointer<ffi.Void> palette;
}

final class FT_Outline_ extends ffi.Struct {
  @ffi.Short()
  external int n_contours;

  @ffi.Short()
  external int n_points;

  external ffi.Pointer<FT_Vector> points;

  external ffi.Pointer<ffi.Char> flags;

  external ffi.Pointer<ffi.Short> contours;

  @ffi.Char()
  external int owner;

  @ffi.Char()
  external int high_precision;

  @ffi.Char()
  external int second_pass;

  @ffi.Char()
  external int dropout_mode;
}

typedef FT_Vector = FT_Vector_;

/// /
final class FT_Outline_Funcs_ extends ffi.Struct {
  external FT_Outline_MoveTo_Func move_to;

  external FT_Outline_LineTo_Func line_to;

  external FT_Outline_ConicTo_Func conic_to;

  external FT_Outline_CubicTo_Func cubic_to;
}

/// /
typedef FT_Outline_MoveTo_Func
    = ffi.Pointer<ffi.NativeFunction<FT_Outline_MoveTo_FuncFunction>>;
typedef FT_Outline_MoveTo_FuncFunction = ffi.Int Function(
    ffi.Pointer<FT_Vector> to, ffi.Pointer<ffi.Void> user);
typedef DartFT_Outline_MoveTo_FuncFunction = int Function(
    ffi.Pointer<FT_Vector> to, ffi.Pointer<ffi.Void> user);

/// /
typedef FT_Outline_LineTo_Func
    = ffi.Pointer<ffi.NativeFunction<FT_Outline_LineTo_FuncFunction>>;
typedef FT_Outline_LineTo_FuncFunction = ffi.Int Function(
    ffi.Pointer<FT_Vector> to, ffi.Pointer<ffi.Void> user);
typedef DartFT_Outline_LineTo_FuncFunction = int Function(
    ffi.Pointer<FT_Vector> to, ffi.Pointer<ffi.Void> user);

/// /
typedef FT_Outline_ConicTo_Func
    = ffi.Pointer<ffi.NativeFunction<FT_Outline_ConicTo_FuncFunction>>;
typedef FT_Outline_ConicTo_FuncFunction = ffi.Int Function(
    ffi.Pointer<FT_Vector> control,
    ffi.Pointer<FT_Vector> to,
    ffi.Pointer<ffi.Void> user);
typedef DartFT_Outline_ConicTo_FuncFunction = int Function(
    ffi.Pointer<FT_Vector> control,
    ffi.Pointer<FT_Vector> to,
    ffi.Pointer<ffi.Void> user);

/// /
typedef FT_Outline_CubicTo_Func
    = ffi.Pointer<ffi.NativeFunction<FT_Outline_CubicTo_FuncFunction>>;
typedef FT_Outline_CubicTo_FuncFunction = ffi.Int Function(
    ffi.Pointer<FT_Vector> control1,
    ffi.Pointer<FT_Vector> control2,
    ffi.Pointer<FT_Vector> to,
    ffi.Pointer<ffi.Void> user);
typedef DartFT_Outline_CubicTo_FuncFunction = int Function(
    ffi.Pointer<FT_Vector> control1,
    ffi.Pointer<FT_Vector> control2,
    ffi.Pointer<FT_Vector> to,
    ffi.Pointer<ffi.Void> user);

/// <Enum>
/// FT_Glyph_Tag
///
/// <Description>
/// An enumeration type used to describethe format of a given glyph
/// image. Note that this version of FreeType only supports two image
/// formats, even though future font drivers will be able to register
/// their own format.
///
/// <Fields>
/// ft_glyph_format_bitmap  :: the glyph image is a bitmap, and can
/// be described as a FT_Bitmap
///
/// ft_glyph_format_outline :: the glyph image is a vectorial image
/// made of bezier control points, and can
/// be described as a FT_Outline
abstract class FT_Glyph_Tag_ {
  static const int ft_glyph_format_none = 0;
  static const int ft_glyph_format_composite = 1668246896;
  static const int ft_glyph_format_bitmap = 1651078259;
  static const int ft_glyph_format_outline = 1869968492;
}

final class FT_RasterRec_ extends ffi.Opaque {}

/// <Struct>
/// FT_Raster_Interface
///
/// <Description>
/// A structure used to model the default raster interface. A raster
/// is a module in charge of converting a glyph image into a bitmap.
///
/// <Fields>
/// size      :: the size in bytes of the given raster object. This
/// is used to allocate a new raster when calling
/// `FT_Set_Raster'.
///
/// format    :: the source glyph image format this raster is able to
/// handle.
///
/// init      :: the raster's initialisation routine
///
/// set_mode  :: the raster's mode set routine
///
/// render    :: the raster's rendering routine
final class FT_Raster_Interface_ extends ffi.Struct {
  @ffi.Long()
  external int size;

  @ffi.Int32()
  external int format_tag;

  external FT_Raster_Init_Proc init;

  external FT_Raster_Set_Mode_Proc set_mode;

  external FT_Raster_Render_Proc render;
}

/// /
typedef FT_Raster_Init_Proc
    = ffi.Pointer<ffi.NativeFunction<FT_Raster_Init_ProcFunction>>;
typedef FT_Raster_Init_ProcFunction = ffi.Int Function(
    FT_Raster raster, ffi.Pointer<ffi.Char> pool_base, ffi.Long pool_size);
typedef DartFT_Raster_Init_ProcFunction = int Function(
    FT_Raster raster, ffi.Pointer<ffi.Char> pool_base, int pool_size);

/// /
typedef FT_Raster = ffi.Pointer<FT_RasterRec_>;

/// /
typedef FT_Raster_Set_Mode_Proc
    = ffi.Pointer<ffi.NativeFunction<FT_Raster_Set_Mode_ProcFunction>>;
typedef FT_Raster_Set_Mode_ProcFunction = ffi.Int Function(
    FT_Raster raster, ffi.Pointer<ffi.Char> mode, ffi.Pointer<ffi.Char> args);
typedef DartFT_Raster_Set_Mode_ProcFunction = int Function(
    FT_Raster raster, ffi.Pointer<ffi.Char> mode, ffi.Pointer<ffi.Char> args);

/// <FuncType>
/// FT_Raster_Render_Proc
///
/// <Description>
/// Renders an outline into a target bitmap/pixmap.
///
/// <Input>
/// raster        :: A handle to a raster object used during rendering.
///
/// source_image  :: a typeless pointer to the source glyph image.
/// (usually a FT_Outline*).
///
/// target_bitmap :: descriptor to the target bitmap.
///
/// <Return>
/// Error code, interpreted as a FT_Error by FreeType library.
/// 0 means success.
typedef FT_Raster_Render_Proc
    = ffi.Pointer<ffi.NativeFunction<FT_Raster_Render_ProcFunction>>;
typedef FT_Raster_Render_ProcFunction = ffi.Int Function(FT_Raster raster,
    ffi.Pointer<ffi.Void> source_image, ffi.Pointer<FT_Bitmap> target_bitmap);
typedef DartFT_Raster_Render_ProcFunction = int Function(FT_Raster raster,
    ffi.Pointer<ffi.Void> source_image, ffi.Pointer<FT_Bitmap> target_bitmap);

/// <Struct>
/// FT_Bitmap
///
/// <Description>
/// A structure used to describe a bitmap or pixmap to the raster.
/// Note that we now manage pixmaps of various depths through the
/// `pixel_mode' field.
///
/// <Fields>
/// rows         :: The number of bitmap rows.
///
/// width        :: The number of pixels in bitmap row.
///
/// pitch        :: The pitch's absolute value is the number of bytes
/// taken by one bitmap row, including padding. However,
/// the pitch is positive when the bitmap has a `down'
/// flow, and negative when it has an `up' flow. In all
/// cases, the pitch is an offset to add to a bitmap
/// pointer in order to go down one row.
///
/// buffer       :: A typeless pointer to the bitmap buffer. This value
/// should be aligned on 32-bit boundaries in most cases.
///
/// num_grays    :: this field is only used with ft_pixel_mode_grays,
/// it gives the number of gray levels used in the
/// bitmap.
///
/// pixel_mode   :: the pixel_mode, i.e. how pixel bits are stored
///
/// palette_mode :: this field is only used with paletted pixel modes,
/// it indicates how the palette is stored
///
/// palette      :: a typeless pointer to the bitmap palette. only used
/// for paletted pixel modes.
///
/// <Note>
/// When using pixel modes pal2, pal4 and pal8 with a void `palette'
/// field, a gray pixmap with respectively 4, 16 and 256 levels of gray
/// is assumed. This, in order to be compatible with some embedded bitmap
/// formats defined in the TrueType spec.
///
/// Note that no font was found presenting such embedded bitmaps, so this
/// is currently completely unhandled by the library.
typedef FT_Bitmap = FT_Bitmap_;

/// /
final class FT_UnitVector_ extends ffi.Struct {
  @FT_F2Dot14()
  external int x;

  @FT_F2Dot14()
  external int y;
}

/// /
typedef FT_F2Dot14 = ffi.Short;
typedef DartFT_F2Dot14 = int;

final class FT_Matrix_ extends ffi.Struct {
  @FT_Fixed()
  external int xx;

  @FT_Fixed()
  external int xy;

  @FT_Fixed()
  external int yx;

  @FT_Fixed()
  external int yy;
}

/// /
typedef FT_Fixed = ffi.Long;
typedef DartFT_Fixed = int;

/// /
final class FT_BBox_ extends ffi.Struct {
  @FT_Pos()
  external int xMin;

  @FT_Pos()
  external int yMin;

  @FT_Pos()
  external int xMax;

  @FT_Pos()
  external int yMax;
}

/// /
final class FT_ListNodeRec_ extends ffi.Struct {
  external FT_ListNode prev;

  external FT_ListNode next;

  external ffi.Pointer<ffi.Void> data;
}

/// /
/// /*************************************************************************/
/// /
typedef FT_ListNode = ffi.Pointer<FT_ListNodeRec_>;

/// /
final class FT_ListRec_ extends ffi.Struct {
  external FT_ListNode head;

  external FT_ListNode tail;
}

/// /
/// /*************************************************************************/
/// /
final class FT_Glyph_Metrics_ extends ffi.Struct {
  @FT_Pos()
  external int width;

  @FT_Pos()
  external int height;

  @FT_Pos()
  external int horiBearingX;

  @FT_Pos()
  external int horiBearingY;

  @FT_Pos()
  external int horiAdvance;

  @FT_Pos()
  external int vertBearingX;

  @FT_Pos()
  external int vertBearingY;

  @FT_Pos()
  external int vertAdvance;
}

/// /
final class FT_Generic_ extends ffi.Struct {
  external ffi.Pointer<ffi.Void> data;

  external FT_Generic_Finalizer finalizer;
}

/// /
typedef FT_Generic_Finalizer
    = ffi.Pointer<ffi.NativeFunction<FT_Generic_FinalizerFunction>>;
typedef FT_Generic_FinalizerFunction = ffi.Void Function(
    ffi.Pointer<ffi.Void> object);
typedef DartFT_Generic_FinalizerFunction = void Function(
    ffi.Pointer<ffi.Void> object);

/// /
final class FT_Bitmap_Size_ extends ffi.Struct {
  @FT_Short()
  external int height;

  @FT_Short()
  external int width;
}

/// /
typedef FT_Short = ffi.Short;
typedef DartFT_Short = int;

final class FT_LibraryRec_ extends ffi.Opaque {}

final class FT_DriverRec_ extends ffi.Opaque {}

final class FT_FaceRec_ extends ffi.Struct {
  external FT_Driver driver;

  external FT_Memory memory;

  external FT_Stream stream;

  @FT_Long()
  external int num_faces;

  @FT_Long()
  external int face_index;

  external FT_Generic generic;

  external FT_GlyphSlot glyph;

  external FT_Size size;

  external FT_CharMap charmap;

  @FT_Int()
  external int num_charmaps;

  external ffi.Pointer<FT_CharMap> charmaps;

  external FT_ListRec sizes_list;

  external ffi.Pointer<ffi.Void> extensions;

  @FT_Long()
  external int face_flags;

  @FT_Long()
  external int style_flags;

  @FT_Long()
  external int num_glyphs;

  external ffi.Pointer<FT_String> family_name;

  external ffi.Pointer<FT_String> style_name;

  @FT_Int()
  external int num_fixed_sizes;

  external ffi.Pointer<FT_Bitmap_Size> available_sizes;

  external FT_BBox bbox;

  @FT_UShort()
  external int units_per_EM;

  @FT_Short()
  external int ascender;

  @FT_Short()
  external int descender;

  @FT_Short()
  external int height;

  @FT_Short()
  external int max_advance_width;

  @FT_Short()
  external int max_advance_height;

  @FT_Short()
  external int underline_position;

  @FT_Short()
  external int underline_thickness;

  @FT_UShort()
  external int max_points;

  @FT_Short()
  external int max_contours;
}

/// /
typedef FT_Driver = ffi.Pointer<FT_DriverRec_>;

/// /
typedef FT_Long = ffi.Long;
typedef DartFT_Long = int;

/// /
typedef FT_Generic = FT_Generic_;

/// /
typedef FT_GlyphSlot = ffi.Pointer<FT_GlyphSlotRec_>;

/// /
final class FT_GlyphSlotRec_ extends ffi.Struct {
  external FT_Face face;

  external FT_GlyphSlot1 next;

  external FT_Glyph_Metrics metrics;

  external FT_Glyph_Metrics metrics2;

  @ffi.Int32()
  external int format;

  external FT_Bitmap bitmap;

  external FT_Outline outline;

  @FT_Int()
  external int num_subglyphs;

  @FT_Int()
  external int max_subglyphs;

  external ffi.Pointer<FT_SubGlyph> subglyphs;

  external ffi.Pointer<ffi.Void> control_data;

  external ffi.Pointer<ffi.Void> control_len;

  external ffi.Pointer<ffi.Void> other;
}

/// /
typedef FT_Face = ffi.Pointer<FT_FaceRec_>;

/// /
typedef FT_GlyphSlot1 = ffi.Pointer<FT_GlyphSlotRec_>;

/// /
/// /*************************************************************************/
/// /
typedef FT_Glyph_Metrics = FT_Glyph_Metrics_;
typedef FT_Outline = FT_Outline_;

/// /
typedef FT_Int = ffi.Int;
typedef DartFT_Int = int;
typedef FT_SubGlyph = FT_SubGlyph_;

final class FT_SubGlyph_ extends ffi.Struct {
  @FT_Int()
  external int index;

  external ffi.Pointer<FT_Byte> control_data;

  @FT_Int()
  external int control_len;

  @FT_UShort()
  external int flags;

  @FT_Int()
  external int arg1;

  @FT_Int()
  external int arg2;

  external FT_Matrix transform;

  external ffi.Pointer<FT_SubGlyph1> parent;
}

/// /
typedef FT_Byte = ffi.UnsignedChar;
typedef DartFT_Byte = int;

/// /
typedef FT_UShort = ffi.UnsignedShort;
typedef DartFT_UShort = int;
typedef FT_Matrix = FT_Matrix_;
typedef FT_SubGlyph1 = FT_SubGlyph_;

/// /
typedef FT_Size = ffi.Pointer<FT_SizeRec_>;

/// /
final class FT_SizeRec_ extends ffi.Struct {
  external FT_Face face;

  external FT_Generic generic;

  external FT_Size_Metrics metrics;
}

/// /
typedef FT_Size_Metrics = FT_Size_Metrics_;

/// /
final class FT_Size_Metrics_ extends ffi.Struct {
  @FT_UShort()
  external int x_ppem;

  @FT_UShort()
  external int y_ppem;

  @FT_Fixed()
  external int x_scale;

  @FT_Fixed()
  external int y_scale;

  @FT_Pos()
  external int ascender;

  @FT_Pos()
  external int descender;

  @FT_Pos()
  external int height;

  @FT_Pos()
  external int max_advance;
}

/// /
typedef FT_CharMap = ffi.Pointer<FT_CharMapRec_>;

/// /
final class FT_CharMapRec_ extends ffi.Struct {
  external FT_Face face;

  @ffi.Int32()
  external int encoding;

  @FT_UShort()
  external int platform_id;

  @FT_UShort()
  external int encoding_id;
}

/// /
abstract class FT_Encoding_ {
  static const int ft_encoding_none = 0;
  static const int ft_encoding_symbol = 0;
  static const int ft_encoding_unicode = 1970170211;
  static const int ft_encoding_latin_2 = 1818326066;
  static const int ft_encoding_sjis = 1936353651;
  static const int ft_encoding_big5 = 1651074869;
  static const int ft_encoding_adobe_standard = 1633972066;
  static const int ft_encoding_adobe_expert = 1633968741;
  static const int ft_encoding_apple_roman = 1634889070;
}

/// /
typedef FT_ListRec = FT_ListRec_;

/// /
typedef FT_String = ffi.Char;
typedef DartFT_String = int;

/// /
typedef FT_Bitmap_Size = FT_Bitmap_Size_;

/// /
typedef FT_BBox = FT_BBox_;

/// /
typedef FT_Error = ffi.Int;
typedef DartFT_Error = int;
typedef FT_Library = ffi.Pointer<FT_LibraryRec_>;

/// /
typedef FT_F26Dot6 = ffi.Long;
typedef DartFT_F26Dot6 = int;

/// /
typedef FT_UInt = ffi.UnsignedInt;
typedef DartFT_UInt = int;

/// /
typedef FT_ULong = ffi.UnsignedLong;
typedef DartFT_ULong = int;

/// /
typedef FT_Outline_Funcs = FT_Outline_Funcs_;

/// <Struct>
/// FT_Raster_Interface
///
/// <Description>
/// A structure used to model the default raster interface. A raster
/// is a module in charge of converting a glyph image into a bitmap.
///
/// <Fields>
/// size      :: the size in bytes of the given raster object. This
/// is used to allocate a new raster when calling
/// `FT_Set_Raster'.
///
/// format    :: the source glyph image format this raster is able to
/// handle.
///
/// init      :: the raster's initialisation routine
///
/// set_mode  :: the raster's mode set routine
///
/// render    :: the raster's rendering routine
typedef FT_Raster_Interface = FT_Raster_Interface_;

const int FREETYPE_MAJOR = 2;

const int FREETYPE_MINOR = 0;

const int FT_Err_Ok = 0;

const int FT_Err_Cannot_Open_Resource = 1;

const int FT_Err_Unknown_File_Format = 2;

const int FT_Err_Invalid_File_Format = 2;

const int FT_Err_Invalid_Argument = 3;

const int FT_Err_Invalid_Handle = 4;

const int FT_Err_Invalid_Glyph_Index = 10;

const int FT_Err_Invalid_Character_Code = 11;

const int FT_Err_Unimplemented_Feature = 16;

const int FT_Err_Invalid_Glyph_Format = 13;

const int FT_Err_Invalid_Library_Handle = 4;

const int FT_Err_Invalid_Driver_Handle = 5;

const int FT_Err_Invalid_Face_Handle = 6;

const int FT_Err_Invalid_Size_Handle = 7;

const int FT_Err_Invalid_Slot_Handle = 8;

const int FT_Err_Invalid_CharMap_Handle = 9;

const int FT_Err_Invalid_Outline = 11;

const int FT_Err_Invalid_Dimensions = 12;

const int FT_Err_Unavailable_Outline = 17;

const int FT_Err_Unavailable_Bitmap = 18;

const int FT_Err_Unavailable_Pixmap = 19;

const int FT_Err_File_Is_Not_Collection = 20;

const int FT_Err_Too_Many_Drivers = 21;

const int FT_Err_Too_Many_Glyph_Formats = 22;

const int FT_Err_Too_Many_Extensions = 23;

const int FT_Err_Out_Of_Memory = 256;

const int FT_Err_Unlisted_Object = 257;

const int FT_Err_Invalid_Resource_Handle = 512;

const int FT_Err_Invalid_Stream_Handle = 513;

const int FT_Err_Cannot_Open_Stream = 514;

const int FT_Err_Invalid_Stream_Seek = 515;

const int FT_Err_Invalid_Stream_Skip = 516;

const int FT_Err_Invalid_Stream_Read = 517;

const int FT_Err_Invalid_Stream_Operation = 518;

const int FT_Err_Invalid_Frame_Operation = 519;

const int FT_Err_Nested_Frame_Access = 520;

const int FT_Err_Invalid_Frame_Read = 521;

const int FT_Err_Too_Many_Points = 768;

const int FT_Err_Too_Many_Contours = 769;

const int FT_Err_Invalid_Composite = 770;

const int FT_Err_Too_Many_Hints = 771;

const int FT_Err_Too_Many_Edges = 772;

const int FT_Err_Too_Many_Strokes = 773;

const int FT_Err_Raster_Uninitialized = 3840;

const int FT_Err_Raster_Corrupted = 3841;

const int FT_Err_Raster_Overflow = 3842;

const int FT_Curve_Tag_On = 1;

const int FT_Curve_Tag_Conic = 0;

const int FT_Curve_Tag_Cubic = 2;

const int FT_Curve_Tag_Touch_X = 8;

const int FT_Curve_Tag_Touch_Y = 16;

const int FT_Curve_Tag_Touch_Both = 24;

const int FT_FACE_FLAG_SCALABLE = 1;

const int FT_FACE_FLAG_FIXED_WIDTH = 4;

const int FT_FACE_FLAG_FIXED_SIZES = 2;

const int FT_FACE_FLAG_SFNT = 8;

const int FT_FACE_FLAG_HORIZONTAL = 16;

const int FT_FACE_FLAG_VERTICAL = 32;

const int FT_FACE_FLAG_KERNING = 64;

const int FT_FACE_FLAG_FAST_GLYPHS = 128;

const int FT_STYLE_FLAG_ITALIC = 1;

const int FT_STYLE_FLAG_BOLD = 2;

const int FT_SUBGLYPH_FLAG_ARGS_ARE_WORDS = 1;

const int FT_SUBGLYPH_FLAG_ARGS_ARE_XY_VALUES = 2;

const int FT_SUBGLYPH_FLAG_ROUND_XY_TO_GRID = 4;

const int FT_SUBGLYPH_FLAG_SCALE = 8;

const int FT_SUBGLYPH_FLAG_XY_SCALE = 64;

const int FT_SUBGLYPH_FLAG_2X2 = 128;

const int FT_SUBGLYPH_FLAG_USE_MY_METRICS = 512;

const int FT_LOAD_NO_SCALE = 1;

const int FT_LOAD_NO_HINTING = 2;

const int FT_LOAD_NO_OUTLINE = 4;

const int FT_LOAD_NO_BITMAP = 8;

const int FT_LOAD_LINEAR = 16;

const int FT_LOAD_PEDANTIC = 128;

const int FT_LOAD_NO_RECURSE = 256;

const int FT_LOAD_DEFAULT = 0;
