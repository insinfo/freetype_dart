// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// @struct:
/// FT_Glyph_Metrics
///
/// @description:
/// A structure to model the metrics of a single glyph.  The values are
/// expressed in 26.6 fractional pixel format; if the flag
/// @FT_LOAD_NO_SCALE has been used while loading the glyph, values are
/// expressed in font units instead.
///
/// @fields:
/// width ::
/// The glyph's width.
///
/// height ::
/// The glyph's height.
///
/// horiBearingX ::
/// Left side bearing for horizontal layout.
///
/// horiBearingY ::
/// Top side bearing for horizontal layout.
///
/// horiAdvance ::
/// Advance width for horizontal layout.
///
/// vertBearingX ::
/// Left side bearing for vertical layout.
///
/// vertBearingY ::
/// Top side bearing for vertical layout.  Larger positive values mean
/// further below the vertical glyph origin.
///
/// vertAdvance ::
/// Advance height for vertical layout.  Positive values mean the glyph
/// has a positive advance downward.
///
/// @note:
/// If not disabled with @FT_LOAD_NO_HINTING, the values represent
/// dimensions of the hinted glyph (in case hinting is applicable).
///
/// Stroking a glyph with an outside border does not increase
/// `horiAdvance` or `vertAdvance`; you have to manually adjust these
/// values to account for the added width and height.
///
/// FreeType doesn't use the 'VORG' table data for CFF fonts because it
/// doesn't have an interface to quickly retrieve the glyph height.  The
/// y~coordinate of the vertical origin can be simply computed as
/// `vertBearingY + height` after loading a glyph.
final class FT_Glyph_Metrics_ extends ffi.Struct {
  @ffi.Int()
  external int width;

  @ffi.Int()
  external int height;

  @ffi.Int()
  external int horiBearingX;

  @ffi.Int()
  external int horiBearingY;

  @ffi.Int()
  external int horiAdvance;

  @ffi.Int()
  external int vertBearingX;

  @ffi.Int()
  external int vertBearingY;

  @ffi.Int()
  external int vertAdvance;
}

/// @struct:
/// FT_Bitmap_Size
///
/// @description:
/// This structure models the metrics of a bitmap strike (i.e., a set of
/// glyphs for a given point size and resolution) in a bitmap font.  It is
/// used for the `available_sizes` field of @FT_Face.
///
/// @fields:
/// height ::
/// The vertical distance, in pixels, between two consecutive baselines.
/// It is always positive.
///
/// width ::
/// The average width, in pixels, of all glyphs in the strike.
///
/// size ::
/// The nominal size of the strike in 26.6 fractional points.  This
/// field is not very useful.
///
/// x_ppem ::
/// The horizontal ppem (nominal width) in 26.6 fractional pixels.
///
/// y_ppem ::
/// The vertical ppem (nominal height) in 26.6 fractional pixels.
///
/// @note:
/// Windows FNT:
/// The nominal size given in a FNT font is not reliable.  If the driver
/// finds it incorrect, it sets `size` to some calculated values, and
/// `x_ppem` and `y_ppem` to the pixel width and height given in the
/// font, respectively.
///
/// TrueType embedded bitmaps:
/// `size`, `width`, and `height` values are not contained in the bitmap
/// strike itself.  They are computed from the global font parameters.
final class FT_Bitmap_Size_ extends ffi.Struct {
  @ffi.Int()
  external int height;

  @ffi.Int()
  external int width;

  @ffi.Int()
  external int size;

  @ffi.Int()
  external int x_ppem;

  @ffi.Int()
  external int y_ppem;
}

final class FT_LibraryRec_ extends ffi.Opaque {}

final class FT_ModuleRec_ extends ffi.Opaque {}

final class FT_DriverRec_ extends ffi.Opaque {}

final class FT_RendererRec_ extends ffi.Opaque {}

/// @struct:
/// FT_FaceRec
///
/// @description:
/// FreeType root face class structure.  A face object models a typeface
/// in a font file.
///
/// @fields:
/// num_faces ::
/// The number of faces in the font file.  Some font formats can have
/// multiple faces in a single font file.
///
/// face_index ::
/// This field holds two different values.  Bits 0-15 are the index of
/// the face in the font file (starting with value~0).  They are set
/// to~0 if there is only one face in the font file.
///
/// [Since 2.6.1] Bits 16-30 are relevant to GX and OpenType variation
/// fonts only, holding the named instance index for the current face
/// index (starting with value~1; value~0 indicates font access without
/// a named instance).  For non-variation fonts, bits 16-30 are ignored.
/// If we have the third named instance of face~4, say, `face_index` is
/// set to 0x00030004.
///
/// Bit 31 is always zero (that is, `face_index` is always a positive
/// value).
///
/// [Since 2.9] Changing the design coordinates with
/// @FT_Set_Var_Design_Coordinates or @FT_Set_Var_Blend_Coordinates does
/// not influence the named instance index value (only
/// @FT_Set_Named_Instance does that).
///
/// face_flags ::
/// A set of bit flags that give important information about the face;
/// see @FT_FACE_FLAG_XXX for the details.
///
/// style_flags ::
/// The lower 16~bits contain a set of bit flags indicating the style of
/// the face; see @FT_STYLE_FLAG_XXX for the details.
///
/// [Since 2.6.1] Bits 16-30 hold the number of named instances
/// available for the current face if we have a GX or OpenType variation
/// (sub)font.  Bit 31 is always zero (that is, `style_flags` is always
/// a positive value).  Note that a variation font has always at least
/// one named instance, namely the default instance.
///
/// num_glyphs ::
/// The number of glyphs in the face.  If the face is scalable and has
/// sbits (see `num_fixed_sizes`), it is set to the number of outline
/// glyphs.
///
/// For CID-keyed fonts (not in an SFNT wrapper) this value gives the
/// highest CID used in the font.
///
/// family_name ::
/// The face's family name.  This is an ASCII string, usually in
/// English, that describes the typeface's family (like 'Times New
/// Roman', 'Bodoni', 'Garamond', etc).  This is a least common
/// denominator used to list fonts.  Some formats (TrueType & OpenType)
/// provide localized and Unicode versions of this string.  Applications
/// should use the format-specific interface to access them.  Can be
/// `NULL` (e.g., in fonts embedded in a PDF file).
///
/// In case the font doesn't provide a specific family name entry,
/// FreeType tries to synthesize one, deriving it from other name
/// entries.
///
/// style_name ::
/// The face's style name.  This is an ASCII string, usually in English,
/// that describes the typeface's style (like 'Italic', 'Bold',
/// 'Condensed', etc).  Not all font formats provide a style name, so
/// this field is optional, and can be set to `NULL`.  As for
/// `family_name`, some formats provide localized and Unicode versions
/// of this string.  Applications should use the format-specific
/// interface to access them.
///
/// num_fixed_sizes ::
/// The number of bitmap strikes in the face.  Even if the face is
/// scalable, there might still be bitmap strikes, which are called
/// 'sbits' in that case.
///
/// available_sizes ::
/// An array of @FT_Bitmap_Size for all bitmap strikes in the face.  It
/// is set to `NULL` if there is no bitmap strike.
///
/// Note that FreeType tries to sanitize the strike data since they are
/// sometimes sloppy or incorrect, but this can easily fail.
///
/// num_charmaps ::
/// The number of charmaps in the face.
///
/// charmaps ::
/// An array of the charmaps of the face.
///
/// generic ::
/// A field reserved for client uses.  See the @FT_Generic type
/// description.
///
/// bbox ::
/// The font bounding box.  Coordinates are expressed in font units (see
/// `units_per_EM`).  The box is large enough to contain any glyph from
/// the font.  Thus, `bbox.yMax` can be seen as the 'maximum ascender',
/// and `bbox.yMin` as the 'minimum descender'.  Only relevant for
/// scalable formats.
///
/// Note that the bounding box might be off by (at least) one pixel for
/// hinted fonts.  See @FT_Size_Metrics for further discussion.
///
/// Note that the bounding box does not vary in OpenType variation fonts
/// and should only be used in relation to the default instance.
///
/// units_per_EM ::
/// The number of font units per EM square for this face.  This is
/// typically 2048 for TrueType fonts, and 1000 for Type~1 fonts.  Only
/// relevant for scalable formats.
///
/// ascender ::
/// The typographic ascender of the face, expressed in font units.  For
/// font formats not having this information, it is set to `bbox.yMax`.
/// Only relevant for scalable formats.
///
/// descender ::
/// The typographic descender of the face, expressed in font units.  For
/// font formats not having this information, it is set to `bbox.yMin`.
/// Note that this field is negative for values below the baseline.
/// Only relevant for scalable formats.
///
/// height ::
/// This value is the vertical distance between two consecutive
/// baselines, expressed in font units.  It is always positive.  Only
/// relevant for scalable formats.
///
/// If you want the global glyph height, use `ascender - descender`.
///
/// max_advance_width ::
/// The maximum advance width, in font units, for all glyphs in this
/// face.  This can be used to make word wrapping computations faster.
/// Only relevant for scalable formats.
///
/// max_advance_height ::
/// The maximum advance height, in font units, for all glyphs in this
/// face.  This is only relevant for vertical layouts, and is set to
/// `height` for fonts that do not provide vertical metrics.  Only
/// relevant for scalable formats.
///
/// underline_position ::
/// The position, in font units, of the underline line for this face.
/// It is the center of the underlining stem.  Only relevant for
/// scalable formats.
///
/// underline_thickness ::
/// The thickness, in font units, of the underline for this face.  Only
/// relevant for scalable formats.
///
/// glyph ::
/// The face's associated glyph slot(s).
///
/// size ::
/// The current active size for this face.
///
/// charmap ::
/// The current active charmap for this face.
///
/// @note:
/// Fields may be changed after a call to @FT_Attach_File or
/// @FT_Attach_Stream.
///
/// For an OpenType variation font, the values of the following fields can
/// change after a call to @FT_Set_Var_Design_Coordinates (and friends) if
/// the font contains an 'MVAR' table: `ascender`, `descender`, `height`,
/// `underline_position`, and `underline_thickness`.
///
/// Especially for TrueType fonts see also the documentation for
/// @FT_Size_Metrics.
final class FT_FaceRec_ extends ffi.Struct {
  @ffi.Int()
  external int num_faces;

  @ffi.Int()
  external int face_index;

  @ffi.Int()
  external int face_flags;

  @ffi.Int()
  external int style_flags;

  @ffi.Int()
  external int num_glyphs;

  external ffi.Pointer<ffi.Int> family_name;

  external ffi.Pointer<ffi.Int> style_name;

  @ffi.Int()
  external int num_fixed_sizes;

  external ffi.Pointer<FT_Bitmap_Size> available_sizes;

  @ffi.Int()
  external int num_charmaps;

  external ffi.Pointer<FT_CharMap> charmaps;

  @ffi.Int()
  external int generic;

  @ffi.Int()
  external int bbox;

  @ffi.Int()
  external int units_per_EM;

  @ffi.Int()
  external int ascender;

  @ffi.Int()
  external int descender;

  @ffi.Int()
  external int height;

  @ffi.Int()
  external int max_advance_width;

  @ffi.Int()
  external int max_advance_height;

  @ffi.Int()
  external int underline_position;

  @ffi.Int()
  external int underline_thickness;

  external FT_GlyphSlot glyph;

  external FT_Size size;

  external FT_CharMap charmap;

  external FT_Driver driver;

  @ffi.Int()
  external int memory;

  @ffi.Int()
  external int stream;

  @ffi.Int()
  external int sizes_list;

  @ffi.Int()
  external int autohint;

  external ffi.Pointer<ffi.Void> extensions;

  external FT_Face_Internal internal;
}

/// @struct:
/// FT_Bitmap_Size
///
/// @description:
/// This structure models the metrics of a bitmap strike (i.e., a set of
/// glyphs for a given point size and resolution) in a bitmap font.  It is
/// used for the `available_sizes` field of @FT_Face.
///
/// @fields:
/// height ::
/// The vertical distance, in pixels, between two consecutive baselines.
/// It is always positive.
///
/// width ::
/// The average width, in pixels, of all glyphs in the strike.
///
/// size ::
/// The nominal size of the strike in 26.6 fractional points.  This
/// field is not very useful.
///
/// x_ppem ::
/// The horizontal ppem (nominal width) in 26.6 fractional pixels.
///
/// y_ppem ::
/// The vertical ppem (nominal height) in 26.6 fractional pixels.
///
/// @note:
/// Windows FNT:
/// The nominal size given in a FNT font is not reliable.  If the driver
/// finds it incorrect, it sets `size` to some calculated values, and
/// `x_ppem` and `y_ppem` to the pixel width and height given in the
/// font, respectively.
///
/// TrueType embedded bitmaps:
/// `size`, `width`, and `height` values are not contained in the bitmap
/// strike itself.  They are computed from the global font parameters.
typedef FT_Bitmap_Size = FT_Bitmap_Size_;

/// @type:
/// FT_CharMap
///
/// @description:
/// A handle to a character map (usually abbreviated to 'charmap').  A
/// charmap is used to translate character codes in a given encoding into
/// glyph indexes for its parent's face.  Some font formats may provide
/// several charmaps per font.
///
/// Each face object owns zero or more charmaps, but only one of them can
/// be 'active', providing the data used by @FT_Get_Char_Index or
/// @FT_Load_Char.
///
/// The list of available charmaps in a face is available through the
/// `face->num_charmaps` and `face->charmaps` fields of @FT_FaceRec.
///
/// The currently active charmap is available as `face->charmap`.  You
/// should call @FT_Set_Charmap to change it.
///
/// @note:
/// When a new face is created (either through @FT_New_Face or
/// @FT_Open_Face), the library looks for a Unicode charmap within the
/// list and automatically activates it.  If there is no Unicode charmap,
/// FreeType doesn't set an 'active' charmap.
///
/// @also:
/// See @FT_CharMapRec for the publicly accessible fields of a given
/// character map.
typedef FT_CharMap = ffi.Pointer<FT_CharMapRec_>;

/// @struct:
/// FT_CharMapRec
///
/// @description:
/// The base charmap structure.
///
/// @fields:
/// face ::
/// A handle to the parent face object.
///
/// encoding ::
/// An @FT_Encoding tag identifying the charmap.  Use this with
/// @FT_Select_Charmap.
///
/// platform_id ::
/// An ID number describing the platform for the following encoding ID.
/// This comes directly from the TrueType specification and gets
/// emulated for other formats.
///
/// encoding_id ::
/// A platform-specific encoding number.  This also comes from the
/// TrueType specification and gets emulated similarly.
final class FT_CharMapRec_ extends ffi.Struct {
  external FT_Face face;

  @ffi.Int32()
  external int encoding;

  @ffi.Int()
  external int platform_id;

  @ffi.Int()
  external int encoding_id;
}

/// @type:
/// FT_Face
///
/// @description:
/// A handle to a typographic face object.  A face object models a given
/// typeface, in a given style.
///
/// @note:
/// A face object also owns a single @FT_GlyphSlot object, as well as one
/// or more @FT_Size objects.
///
/// Use @FT_New_Face or @FT_Open_Face to create a new face object from a
/// given filepath or a custom input stream.
///
/// Use @FT_Done_Face to destroy it (along with its slot and sizes).
///
/// An `FT_Face` object can only be safely used from one thread at a time.
/// Similarly, creation and destruction of `FT_Face` with the same
/// @FT_Library object can only be done from one thread at a time.  On the
/// other hand, functions like @FT_Load_Glyph and its siblings are
/// thread-safe and do not need the lock to be held as long as the same
/// `FT_Face` object is not used from multiple threads at the same time.
///
/// @also:
/// See @FT_FaceRec for the publicly accessible fields of a given face
/// object.
typedef FT_Face = ffi.Pointer<FT_FaceRec_>;

/// @enum:
/// FT_Encoding
///
/// @description:
/// An enumeration to specify character sets supported by charmaps.  Used
/// in the @FT_Select_Charmap API function.
///
/// @note:
/// Despite the name, this enumeration lists specific character
/// repertoires (i.e., charsets), and not text encoding methods (e.g.,
/// UTF-8, UTF-16, etc.).
///
/// Other encodings might be defined in the future.
///
/// @values:
/// FT_ENCODING_NONE ::
/// The encoding value~0 is reserved for all formats except BDF, PCF,
/// and Windows FNT; see below for more information.
///
/// FT_ENCODING_UNICODE ::
/// The Unicode character set.  This value covers all versions of the
/// Unicode repertoire, including ASCII and Latin-1.  Most fonts include
/// a Unicode charmap, but not all of them.
///
/// For example, if you want to access Unicode value U+1F028 (and the
/// font contains it), use value 0x1F028 as the input value for
/// @FT_Get_Char_Index.
///
/// FT_ENCODING_MS_SYMBOL ::
/// Microsoft Symbol encoding, used to encode mathematical symbols and
/// wingdings.  For more information, see
/// 'https://www.microsoft.com/typography/otspec/recom.htm#non-standard-symbol-fonts',
/// 'http://www.kostis.net/charsets/symbol.htm', and
/// 'http://www.kostis.net/charsets/wingding.htm'.
///
/// This encoding uses character codes from the PUA (Private Unicode
/// Area) in the range U+F020-U+F0FF.
///
/// FT_ENCODING_SJIS ::
/// Shift JIS encoding for Japanese.  More info at
/// 'https://en.wikipedia.org/wiki/Shift_JIS'.  See note on multi-byte
/// encodings below.
///
/// FT_ENCODING_PRC ::
/// Corresponds to encoding systems mainly for Simplified Chinese as
/// used in People's Republic of China (PRC).  The encoding layout is
/// based on GB~2312 and its supersets GBK and GB~18030.
///
/// FT_ENCODING_BIG5 ::
/// Corresponds to an encoding system for Traditional Chinese as used in
/// Taiwan and Hong Kong.
///
/// FT_ENCODING_WANSUNG ::
/// Corresponds to the Korean encoding system known as Extended Wansung
/// (MS Windows code page 949).  For more information see
/// 'https://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WindowsBestFit/bestfit949.txt'.
///
/// FT_ENCODING_JOHAB ::
/// The Korean standard character set (KS~C 5601-1992), which
/// corresponds to MS Windows code page 1361.  This character set
/// includes all possible Hangul character combinations.
///
/// FT_ENCODING_ADOBE_LATIN_1 ::
/// Corresponds to a Latin-1 encoding as defined in a Type~1 PostScript
/// font.  It is limited to 256 character codes.
///
/// FT_ENCODING_ADOBE_STANDARD ::
/// Adobe Standard encoding, as found in Type~1, CFF, and OpenType/CFF
/// fonts.  It is limited to 256 character codes.
///
/// FT_ENCODING_ADOBE_EXPERT ::
/// Adobe Expert encoding, as found in Type~1, CFF, and OpenType/CFF
/// fonts.  It is limited to 256 character codes.
///
/// FT_ENCODING_ADOBE_CUSTOM ::
/// Corresponds to a custom encoding, as found in Type~1, CFF, and
/// OpenType/CFF fonts.  It is limited to 256 character codes.
///
/// FT_ENCODING_APPLE_ROMAN ::
/// Apple roman encoding.  Many TrueType and OpenType fonts contain a
/// charmap for this 8-bit encoding, since older versions of Mac OS are
/// able to use it.
///
/// FT_ENCODING_OLD_LATIN_2 ::
/// This value is deprecated and was neither used nor reported by
/// FreeType.  Don't use or test for it.
///
/// FT_ENCODING_MS_SJIS ::
/// Same as FT_ENCODING_SJIS.  Deprecated.
///
/// FT_ENCODING_MS_GB2312 ::
/// Same as FT_ENCODING_PRC.  Deprecated.
///
/// FT_ENCODING_MS_BIG5 ::
/// Same as FT_ENCODING_BIG5.  Deprecated.
///
/// FT_ENCODING_MS_WANSUNG ::
/// Same as FT_ENCODING_WANSUNG.  Deprecated.
///
/// FT_ENCODING_MS_JOHAB ::
/// Same as FT_ENCODING_JOHAB.  Deprecated.
///
/// @note:
/// When loading a font, FreeType makes a Unicode charmap active if
/// possible (either if the font provides such a charmap, or if FreeType
/// can synthesize one from PostScript glyph name dictionaries; in either
/// case, the charmap is tagged with `FT_ENCODING_UNICODE`).  If such a
/// charmap is synthesized, it is placed at the first position of the
/// charmap array.
///
/// All other encodings are considered legacy and tagged only if
/// explicitly defined in the font file.  Otherwise, `FT_ENCODING_NONE` is
/// used.
///
/// `FT_ENCODING_NONE` is set by the BDF and PCF drivers if the charmap is
/// neither Unicode nor ISO-8859-1 (otherwise it is set to
/// `FT_ENCODING_UNICODE`).  Use @FT_Get_BDF_Charset_ID to find out which
/// encoding is really present.  If, for example, the `cs_registry` field
/// is 'KOI8' and the `cs_encoding` field is 'R', the font is encoded in
/// KOI8-R.
///
/// `FT_ENCODING_NONE` is always set (with a single exception) by the
/// winfonts driver.  Use @FT_Get_WinFNT_Header and examine the `charset`
/// field of the @FT_WinFNT_HeaderRec structure to find out which encoding
/// is really present.  For example, @FT_WinFNT_ID_CP1251 (204) means
/// Windows code page 1251 (for Russian).
///
/// `FT_ENCODING_NONE` is set if `platform_id` is @TT_PLATFORM_MACINTOSH
/// and `encoding_id` is not `TT_MAC_ID_ROMAN` (otherwise it is set to
/// `FT_ENCODING_APPLE_ROMAN`).
///
/// If `platform_id` is @TT_PLATFORM_MACINTOSH, use the function
/// @FT_Get_CMap_Language_ID to query the Mac language ID that may be
/// needed to be able to distinguish Apple encoding variants.  See
///
/// https://www.unicode.org/Public/MAPPINGS/VENDORS/APPLE/Readme.txt
///
/// to get an idea how to do that.  Basically, if the language ID is~0,
/// don't use it, otherwise subtract 1 from the language ID.  Then examine
/// `encoding_id`.  If, for example, `encoding_id` is `TT_MAC_ID_ROMAN`
/// and the language ID (minus~1) is `TT_MAC_LANGID_GREEK`, it is the
/// Greek encoding, not Roman.  `TT_MAC_ID_ARABIC` with
/// `TT_MAC_LANGID_FARSI` means the Farsi variant of the Arabic encoding.
abstract class FT_Encoding_ {
  static const int FT_ENCODING_NONE = 0;
  static const int FT_ENCODING_MS_SYMBOL = 1;
  static const int FT_ENCODING_UNICODE = 2;
  static const int FT_ENCODING_SJIS = 3;
  static const int FT_ENCODING_PRC = 4;
  static const int FT_ENCODING_BIG5 = 5;
  static const int FT_ENCODING_WANSUNG = 6;
  static const int FT_ENCODING_JOHAB = 7;
  static const int FT_ENCODING_GB2312 = 4;
  static const int FT_ENCODING_MS_SJIS = 3;
  static const int FT_ENCODING_MS_GB2312 = 4;
  static const int FT_ENCODING_MS_BIG5 = 5;
  static const int FT_ENCODING_MS_WANSUNG = 6;
  static const int FT_ENCODING_MS_JOHAB = 7;
  static const int FT_ENCODING_ADOBE_STANDARD = 8;
  static const int FT_ENCODING_ADOBE_EXPERT = 9;
  static const int FT_ENCODING_ADOBE_CUSTOM = 10;
  static const int FT_ENCODING_ADOBE_LATIN_1 = 11;
  static const int FT_ENCODING_OLD_LATIN_2 = 12;
  static const int FT_ENCODING_APPLE_ROMAN = 13;
}

/// @type:
/// FT_GlyphSlot
///
/// @description:
/// A handle to a given 'glyph slot'.  A slot is a container that can hold
/// any of the glyphs contained in its parent face.
///
/// In other words, each time you call @FT_Load_Glyph or @FT_Load_Char,
/// the slot's content is erased by the new glyph data, i.e., the glyph's
/// metrics, its image (bitmap or outline), and other control information.
///
/// @also:
/// See @FT_GlyphSlotRec for the publicly accessible glyph fields.
typedef FT_GlyphSlot = ffi.Pointer<FT_GlyphSlotRec_>;

/// @struct:
/// FT_GlyphSlotRec
///
/// @description:
/// FreeType root glyph slot class structure.  A glyph slot is a container
/// where individual glyphs can be loaded, be they in outline or bitmap
/// format.
///
/// @fields:
/// library ::
/// A handle to the FreeType library instance this slot belongs to.
///
/// face ::
/// A handle to the parent face object.
///
/// next ::
/// In some cases (like some font tools), several glyph slots per face
/// object can be a good thing.  As this is rare, the glyph slots are
/// listed through a direct, single-linked list using its `next` field.
///
/// glyph_index ::
/// [Since 2.10] The glyph index passed as an argument to @FT_Load_Glyph
/// while initializing the glyph slot.
///
/// generic ::
/// A typeless pointer unused by the FreeType library or any of its
/// drivers.  It can be used by client applications to link their own
/// data to each glyph slot object.
///
/// metrics ::
/// The metrics of the last loaded glyph in the slot.  The returned
/// values depend on the last load flags (see the @FT_Load_Glyph API
/// function) and can be expressed either in 26.6 fractional pixels or
/// font units.
///
/// Note that even when the glyph image is transformed, the metrics are
/// not.
///
/// linearHoriAdvance ::
/// The advance width of the unhinted glyph.  Its value is expressed in
/// 16.16 fractional pixels, unless @FT_LOAD_LINEAR_DESIGN is set when
/// loading the glyph.  This field can be important to perform correct
/// WYSIWYG layout.  Only relevant for scalable glyphs.
///
/// linearVertAdvance ::
/// The advance height of the unhinted glyph.  Its value is expressed in
/// 16.16 fractional pixels, unless @FT_LOAD_LINEAR_DESIGN is set when
/// loading the glyph.  This field can be important to perform correct
/// WYSIWYG layout.  Only relevant for scalable glyphs.
///
/// advance ::
/// This shorthand is, depending on @FT_LOAD_IGNORE_TRANSFORM, the
/// transformed (hinted) advance width for the glyph, in 26.6 fractional
/// pixel format.  As specified with @FT_LOAD_VERTICAL_LAYOUT, it uses
/// either the `horiAdvance` or the `vertAdvance` value of `metrics`
/// field.
///
/// format ::
/// This field indicates the format of the image contained in the glyph
/// slot.  Typically @FT_GLYPH_FORMAT_BITMAP, @FT_GLYPH_FORMAT_OUTLINE,
/// or @FT_GLYPH_FORMAT_COMPOSITE, but other values are possible.
///
/// bitmap ::
/// This field is used as a bitmap descriptor.  Note that the address
/// and content of the bitmap buffer can change between calls of
/// @FT_Load_Glyph and a few other functions.
///
/// bitmap_left ::
/// The bitmap's left bearing expressed in integer pixels.
///
/// bitmap_top ::
/// The bitmap's top bearing expressed in integer pixels.  This is the
/// distance from the baseline to the top-most glyph scanline, upwards
/// y~coordinates being **positive**.
///
/// outline ::
/// The outline descriptor for the current glyph image if its format is
/// @FT_GLYPH_FORMAT_OUTLINE.  Once a glyph is loaded, `outline` can be
/// transformed, distorted, emboldened, etc.  However, it must not be
/// freed.
///
/// [Since 2.10.1] If @FT_LOAD_NO_SCALE is set, outline coordinates of
/// OpenType variation fonts for a selected instance are internally
/// handled as 26.6 fractional font units but returned as (rounded)
/// integers, as expected.  To get unrounded font units, don't use
/// @FT_LOAD_NO_SCALE but load the glyph with @FT_LOAD_NO_HINTING and
/// scale it, using the font's `units_per_EM` value as the ppem.
///
/// num_subglyphs ::
/// The number of subglyphs in a composite glyph.  This field is only
/// valid for the composite glyph format that should normally only be
/// loaded with the @FT_LOAD_NO_RECURSE flag.
///
/// subglyphs ::
/// An array of subglyph descriptors for composite glyphs.  There are
/// `num_subglyphs` elements in there.  Currently internal to FreeType.
///
/// control_data ::
/// Certain font drivers can also return the control data for a given
/// glyph image (e.g.  TrueType bytecode, Type~1 charstrings, etc.).
/// This field is a pointer to such data; it is currently internal to
/// FreeType.
///
/// control_len ::
/// This is the length in bytes of the control data.  Currently internal
/// to FreeType.
///
/// other ::
/// Reserved.
///
/// lsb_delta ::
/// The difference between hinted and unhinted left side bearing while
/// auto-hinting is active.  Zero otherwise.
///
/// rsb_delta ::
/// The difference between hinted and unhinted right side bearing while
/// auto-hinting is active.  Zero otherwise.
///
/// @note:
/// If @FT_Load_Glyph is called with default flags (see @FT_LOAD_DEFAULT)
/// the glyph image is loaded in the glyph slot in its native format
/// (e.g., an outline glyph for TrueType and Type~1 formats).  [Since 2.9]
/// The prospective bitmap metrics are calculated according to
/// @FT_LOAD_TARGET_XXX and other flags even for the outline glyph, even
/// if @FT_LOAD_RENDER is not set.
///
/// This image can later be converted into a bitmap by calling
/// @FT_Render_Glyph.  This function searches the current renderer for the
/// native image's format, then invokes it.
///
/// The renderer is in charge of transforming the native image through the
/// slot's face transformation fields, then converting it into a bitmap
/// that is returned in `slot->bitmap`.
///
/// Note that `slot->bitmap_left` and `slot->bitmap_top` are also used to
/// specify the position of the bitmap relative to the current pen
/// position (e.g., coordinates (0,0) on the baseline).  Of course,
/// `slot->format` is also changed to @FT_GLYPH_FORMAT_BITMAP.
///
/// Here is a small pseudo code fragment that shows how to use `lsb_delta`
/// and `rsb_delta` to do fractional positioning of glyphs:
///
/// ```
/// FT_GlyphSlot  slot     = face->glyph;
/// FT_Pos        origin_x = 0;
///
///
/// for all glyphs do
/// <load glyph with `FT_Load_Glyph'>
///
/// FT_Outline_Translate( slot->outline, origin_x & 63, 0 );
///
/// <save glyph image, or render glyph, or ...>
///
/// <compute kern between current and next glyph
/// and add it to `origin_x'>
///
/// origin_x += slot->advance.x;
/// origin_x += slot->lsb_delta - slot->rsb_delta;
/// endfor
/// ```
///
/// Here is another small pseudo code fragment that shows how to use
/// `lsb_delta` and `rsb_delta` to improve integer positioning of glyphs:
///
/// ```
/// FT_GlyphSlot  slot           = face->glyph;
/// FT_Pos        origin_x       = 0;
/// FT_Pos        prev_rsb_delta = 0;
///
///
/// for all glyphs do
/// <compute kern between current and previous glyph
/// and add it to `origin_x'>
///
/// <load glyph with `FT_Load_Glyph'>
///
/// if ( prev_rsb_delta - slot->lsb_delta >  32 )
/// origin_x -= 64;
/// else if ( prev_rsb_delta - slot->lsb_delta < -31 )
/// origin_x += 64;
///
/// prev_rsb_delta = slot->rsb_delta;
///
/// <save glyph image, or render glyph, or ...>
///
/// origin_x += slot->advance.x;
/// endfor
/// ```
///
/// If you use strong auto-hinting, you **must** apply these delta values!
/// Otherwise you will experience far too large inter-glyph spacing at
/// small rendering sizes in most cases.  Note that it doesn't harm to use
/// the above code for other hinting modes also, since the delta values
/// are zero then.
final class FT_GlyphSlotRec_ extends ffi.Struct {
  external FT_Library library1;

  external FT_Face face;

  external FT_GlyphSlot1 next;

  @ffi.Int()
  external int glyph_index;

  @ffi.Int()
  external int generic;

  @FT_Glyph_Metrics()
  external int metrics;

  @ffi.Int()
  external int linearHoriAdvance;

  @ffi.Int()
  external int linearVertAdvance;

  @ffi.Int()
  external int advance;

  @ffi.Int()
  external int format;

  @ffi.Int()
  external int bitmap;

  @ffi.Int()
  external int bitmap_left;

  @ffi.Int()
  external int bitmap_top;

  @ffi.Int()
  external int outline;

  @ffi.Int()
  external int num_subglyphs;

  external FT_SubGlyph subglyphs;

  external ffi.Pointer<ffi.Void> control_data;

  @ffi.Long()
  external int control_len;

  @ffi.Int()
  external int lsb_delta;

  @ffi.Int()
  external int rsb_delta;

  external ffi.Pointer<ffi.Void> other;

  external FT_Slot_Internal internal;
}

/// @type:
/// FT_Library
///
/// @description:
/// A handle to a FreeType library instance.  Each 'library' is completely
/// independent from the others; it is the 'root' of a set of objects like
/// fonts, faces, sizes, etc.
///
/// It also embeds a memory manager (see @FT_Memory), as well as a
/// scan-line converter object (see @FT_Raster).
///
/// [Since 2.5.6] In multi-threaded applications it is easiest to use one
/// `FT_Library` object per thread.  In case this is too cumbersome, a
/// single `FT_Library` object across threads is possible also, as long as
/// a mutex lock is used around @FT_New_Face and @FT_Done_Face.
///
/// @note:
/// Library objects are normally created by @FT_Init_FreeType, and
/// destroyed with @FT_Done_FreeType.  If you need reference-counting
/// (cf. @FT_Reference_Library), use @FT_New_Library and @FT_Done_Library.
typedef FT_Library = ffi.Pointer<FT_LibraryRec_>;

/// @type:
/// FT_GlyphSlot
///
/// @description:
/// A handle to a given 'glyph slot'.  A slot is a container that can hold
/// any of the glyphs contained in its parent face.
///
/// In other words, each time you call @FT_Load_Glyph or @FT_Load_Char,
/// the slot's content is erased by the new glyph data, i.e., the glyph's
/// metrics, its image (bitmap or outline), and other control information.
///
/// @also:
/// See @FT_GlyphSlotRec for the publicly accessible glyph fields.
typedef FT_GlyphSlot1 = ffi.Pointer<FT_GlyphSlotRec_>;
typedef FT_Glyph_Metrics = ffi.Int;
typedef DartFT_Glyph_Metrics = int;

/// @struct:
/// FT_SubGlyph
///
/// @description:
/// The subglyph structure is an internal object used to describe
/// subglyphs (for example, in the case of composites).
///
/// @note:
/// The subglyph implementation is not part of the high-level API, hence
/// the forward structure declaration.
///
/// You can however retrieve subglyph information with
/// @FT_Get_SubGlyph_Info.
typedef FT_SubGlyph = ffi.Pointer<FT_SubGlyphRec_>;

final class FT_SubGlyphRec_ extends ffi.Opaque {}

/// @type:
/// FT_Slot_Internal
///
/// @description:
/// An opaque handle to an `FT_Slot_InternalRec` structure, used to model
/// private data of a given @FT_GlyphSlot object.
typedef FT_Slot_Internal = ffi.Pointer<FT_Slot_InternalRec_>;

final class FT_Slot_InternalRec_ extends ffi.Opaque {}

/// @type:
/// FT_Size
///
/// @description:
/// A handle to an object that models a face scaled to a given character
/// size.
///
/// @note:
/// An @FT_Face has one _active_ `FT_Size` object that is used by
/// functions like @FT_Load_Glyph to determine the scaling transformation
/// that in turn is used to load and hint glyphs and metrics.
///
/// A newly created `FT_Size` object contains only meaningless zero values.
/// You must use @FT_Set_Char_Size, @FT_Set_Pixel_Sizes, @FT_Request_Size
/// or even @FT_Select_Size to change the content (i.e., the scaling
/// values) of the active `FT_Size`.  Otherwise, the scaling and hinting
/// will not be performed.
///
/// You can use @FT_New_Size to create additional size objects for a given
/// @FT_Face, but they won't be used by other functions until you activate
/// it through @FT_Activate_Size.  Only one size can be activated at any
/// given time per face.
///
/// @also:
/// See @FT_SizeRec for the publicly accessible fields of a given size
/// object.
typedef FT_Size = ffi.Pointer<FT_SizeRec_>;

/// @struct:
/// FT_SizeRec
///
/// @description:
/// FreeType root size class structure.  A size object models a face
/// object at a given size.
///
/// @fields:
/// face ::
/// Handle to the parent face object.
///
/// generic ::
/// A typeless pointer, unused by the FreeType library or any of its
/// drivers.  It can be used by client applications to link their own
/// data to each size object.
///
/// metrics ::
/// Metrics for this size object.  This field is read-only.
final class FT_SizeRec_ extends ffi.Struct {
  external FT_Face face;

  @ffi.Int()
  external int generic;

  external FT_Size_Metrics metrics;

  external FT_Size_Internal internal;
}

/// @struct:
/// FT_Size_Metrics
///
/// @description:
/// The size metrics structure gives the metrics of a size object.
///
/// @fields:
/// x_ppem ::
/// The width of the scaled EM square in pixels, hence the term 'ppem'
/// (pixels per EM).  It is also referred to as 'nominal width'.
///
/// y_ppem ::
/// The height of the scaled EM square in pixels, hence the term 'ppem'
/// (pixels per EM).  It is also referred to as 'nominal height'.
///
/// x_scale ::
/// A 16.16 fractional scaling value to convert horizontal metrics from
/// font units to 26.6 fractional pixels.  Only relevant for scalable
/// font formats.
///
/// y_scale ::
/// A 16.16 fractional scaling value to convert vertical metrics from
/// font units to 26.6 fractional pixels.  Only relevant for scalable
/// font formats.
///
/// ascender ::
/// The ascender in 26.6 fractional pixels, rounded up to an integer
/// value.  See @FT_FaceRec for the details.
///
/// descender ::
/// The descender in 26.6 fractional pixels, rounded down to an integer
/// value.  See @FT_FaceRec for the details.
///
/// height ::
/// The height in 26.6 fractional pixels, rounded to an integer value.
/// See @FT_FaceRec for the details.
///
/// max_advance ::
/// The maximum advance width in 26.6 fractional pixels, rounded to an
/// integer value.  See @FT_FaceRec for the details.
///
/// @note:
/// The scaling values, if relevant, are determined first during a size
/// changing operation.  The remaining fields are then set by the driver.
/// For scalable formats, they are usually set to scaled values of the
/// corresponding fields in @FT_FaceRec.  Some values like ascender or
/// descender are rounded for historical reasons; more precise values (for
/// outline fonts) can be derived by scaling the corresponding @FT_FaceRec
/// values manually, with code similar to the following.
///
/// ```
/// scaled_ascender = FT_MulFix( face->ascender,
/// size_metrics->y_scale );
/// ```
///
/// Note that due to glyph hinting and the selected rendering mode these
/// values are usually not exact; consequently, they must be treated as
/// unreliable with an error margin of at least one pixel!
///
/// Indeed, the only way to get the exact metrics is to render _all_
/// glyphs.  As this would be a definite performance hit, it is up to
/// client applications to perform such computations.
///
/// The `FT_Size_Metrics` structure is valid for bitmap fonts also.
///
///
/// **TrueType fonts with native bytecode hinting**
///
/// All applications that handle TrueType fonts with native hinting must
/// be aware that TTFs expect different rounding of vertical font
/// dimensions.  The application has to cater for this, especially if it
/// wants to rely on a TTF's vertical data (for example, to properly align
/// box characters vertically).
///
/// Only the application knows _in advance_ that it is going to use native
/// hinting for TTFs!  FreeType, on the other hand, selects the hinting
/// mode not at the time of creating an @FT_Size object but much later,
/// namely while calling @FT_Load_Glyph.
///
/// Here is some pseudo code that illustrates a possible solution.
///
/// ```
/// font_format = FT_Get_Font_Format( face );
///
/// if ( !strcmp( font_format, "TrueType" ) &&
/// do_native_bytecode_hinting         )
/// {
/// ascender  = ROUND( FT_MulFix( face->ascender,
/// size_metrics->y_scale ) );
/// descender = ROUND( FT_MulFix( face->descender,
/// size_metrics->y_scale ) );
/// }
/// else
/// {
/// ascender  = size_metrics->ascender;
/// descender = size_metrics->descender;
/// }
///
/// height      = size_metrics->height;
/// max_advance = size_metrics->max_advance;
/// ```
typedef FT_Size_Metrics = FT_Size_Metrics_;

/// @struct:
/// FT_Size_Metrics
///
/// @description:
/// The size metrics structure gives the metrics of a size object.
///
/// @fields:
/// x_ppem ::
/// The width of the scaled EM square in pixels, hence the term 'ppem'
/// (pixels per EM).  It is also referred to as 'nominal width'.
///
/// y_ppem ::
/// The height of the scaled EM square in pixels, hence the term 'ppem'
/// (pixels per EM).  It is also referred to as 'nominal height'.
///
/// x_scale ::
/// A 16.16 fractional scaling value to convert horizontal metrics from
/// font units to 26.6 fractional pixels.  Only relevant for scalable
/// font formats.
///
/// y_scale ::
/// A 16.16 fractional scaling value to convert vertical metrics from
/// font units to 26.6 fractional pixels.  Only relevant for scalable
/// font formats.
///
/// ascender ::
/// The ascender in 26.6 fractional pixels, rounded up to an integer
/// value.  See @FT_FaceRec for the details.
///
/// descender ::
/// The descender in 26.6 fractional pixels, rounded down to an integer
/// value.  See @FT_FaceRec for the details.
///
/// height ::
/// The height in 26.6 fractional pixels, rounded to an integer value.
/// See @FT_FaceRec for the details.
///
/// max_advance ::
/// The maximum advance width in 26.6 fractional pixels, rounded to an
/// integer value.  See @FT_FaceRec for the details.
///
/// @note:
/// The scaling values, if relevant, are determined first during a size
/// changing operation.  The remaining fields are then set by the driver.
/// For scalable formats, they are usually set to scaled values of the
/// corresponding fields in @FT_FaceRec.  Some values like ascender or
/// descender are rounded for historical reasons; more precise values (for
/// outline fonts) can be derived by scaling the corresponding @FT_FaceRec
/// values manually, with code similar to the following.
///
/// ```
/// scaled_ascender = FT_MulFix( face->ascender,
/// size_metrics->y_scale );
/// ```
///
/// Note that due to glyph hinting and the selected rendering mode these
/// values are usually not exact; consequently, they must be treated as
/// unreliable with an error margin of at least one pixel!
///
/// Indeed, the only way to get the exact metrics is to render _all_
/// glyphs.  As this would be a definite performance hit, it is up to
/// client applications to perform such computations.
///
/// The `FT_Size_Metrics` structure is valid for bitmap fonts also.
///
///
/// **TrueType fonts with native bytecode hinting**
///
/// All applications that handle TrueType fonts with native hinting must
/// be aware that TTFs expect different rounding of vertical font
/// dimensions.  The application has to cater for this, especially if it
/// wants to rely on a TTF's vertical data (for example, to properly align
/// box characters vertically).
///
/// Only the application knows _in advance_ that it is going to use native
/// hinting for TTFs!  FreeType, on the other hand, selects the hinting
/// mode not at the time of creating an @FT_Size object but much later,
/// namely while calling @FT_Load_Glyph.
///
/// Here is some pseudo code that illustrates a possible solution.
///
/// ```
/// font_format = FT_Get_Font_Format( face );
///
/// if ( !strcmp( font_format, "TrueType" ) &&
/// do_native_bytecode_hinting         )
/// {
/// ascender  = ROUND( FT_MulFix( face->ascender,
/// size_metrics->y_scale ) );
/// descender = ROUND( FT_MulFix( face->descender,
/// size_metrics->y_scale ) );
/// }
/// else
/// {
/// ascender  = size_metrics->ascender;
/// descender = size_metrics->descender;
/// }
///
/// height      = size_metrics->height;
/// max_advance = size_metrics->max_advance;
/// ```
final class FT_Size_Metrics_ extends ffi.Struct {
  @ffi.Int()
  external int x_ppem;

  @ffi.Int()
  external int y_ppem;

  @ffi.Int()
  external int x_scale;

  @ffi.Int()
  external int y_scale;

  @ffi.Int()
  external int ascender;

  @ffi.Int()
  external int descender;

  @ffi.Int()
  external int height;

  @ffi.Int()
  external int max_advance;
}

/// @type:
/// FT_Size_Internal
///
/// @description:
/// An opaque handle to an `FT_Size_InternalRec` structure, used to model
/// private data of a given @FT_Size object.
typedef FT_Size_Internal = ffi.Pointer<FT_Size_InternalRec_>;

final class FT_Size_InternalRec_ extends ffi.Opaque {}

/// @type:
/// FT_Driver
///
/// @description:
/// A handle to a given FreeType font driver object.  A font driver is a
/// module capable of creating faces from font files.
typedef FT_Driver = ffi.Pointer<FT_DriverRec_>;

/// @type:
/// FT_Face_Internal
///
/// @description:
/// An opaque handle to an `FT_Face_InternalRec` structure that models the
/// private data of a given @FT_Face object.
///
/// This structure might change between releases of FreeType~2 and is not
/// generally available to client applications.
typedef FT_Face_Internal = ffi.Pointer<FT_Face_InternalRec_>;

final class FT_Face_InternalRec_ extends ffi.Opaque {}

/// @struct:
/// FT_Parameter
///
/// @description:
/// A simple structure to pass more or less generic parameters to
/// @FT_Open_Face and @FT_Face_Properties.
///
/// @fields:
/// tag ::
/// A four-byte identification tag.
///
/// data ::
/// A pointer to the parameter data.
///
/// @note:
/// The ID and function of parameters are driver-specific.  See section
/// @parameter_tags for more information.
final class FT_Parameter_ extends ffi.Struct {
  @ffi.Int()
  external int tag;

  @ffi.Int()
  external int data;
}

/// @struct:
/// FT_Open_Args
///
/// @description:
/// A structure to indicate how to open a new font file or stream.  A
/// pointer to such a structure can be used as a parameter for the
/// functions @FT_Open_Face and @FT_Attach_Stream.
///
/// @fields:
/// flags ::
/// A set of bit flags indicating how to use the structure.
///
/// memory_base ::
/// The first byte of the file in memory.
///
/// memory_size ::
/// The size in bytes of the file in memory.
///
/// pathname ::
/// A pointer to an 8-bit file pathname, which must be a C~string (i.e.,
/// no null bytes except at the very end).  The pointer is not owned by
/// FreeType.
///
/// stream ::
/// A handle to a source stream object.
///
/// driver ::
/// This field is exclusively used by @FT_Open_Face; it simply specifies
/// the font driver to use for opening the face.  If set to `NULL`,
/// FreeType tries to load the face with each one of the drivers in its
/// list.
///
/// num_params ::
/// The number of extra parameters.
///
/// params ::
/// Extra parameters passed to the font driver when opening a new face.
///
/// @note:
/// The stream type is determined by the contents of `flags`:
///
/// If the @FT_OPEN_MEMORY bit is set, assume that this is a memory file
/// of `memory_size` bytes, located at `memory_address`.  The data are not
/// copied, and the client is responsible for releasing and destroying
/// them _after_ the corresponding call to @FT_Done_Face.
///
/// Otherwise, if the @FT_OPEN_STREAM bit is set, assume that a custom
/// input stream `stream` is used.
///
/// Otherwise, if the @FT_OPEN_PATHNAME bit is set, assume that this is a
/// normal file and use `pathname` to open it.
///
/// If none of the above bits are set or if multiple are set at the same
/// time, the flags are invalid and @FT_Open_Face fails.
///
/// If the @FT_OPEN_DRIVER bit is set, @FT_Open_Face only tries to open
/// the file with the driver whose handler is in `driver`.
///
/// If the @FT_OPEN_PARAMS bit is set, the parameters given by
/// `num_params` and `params` is used.  They are ignored otherwise.
///
/// Ideally, both the `pathname` and `params` fields should be tagged as
/// 'const'; this is missing for API backward compatibility.  In other
/// words, applications should treat them as read-only.
final class FT_Open_Args_ extends ffi.Struct {
  @ffi.Int()
  external int flags;

  external ffi.Pointer<ffi.Int> memory_base;

  @ffi.Int()
  external int memory_size;

  external ffi.Pointer<ffi.Int> pathname;

  @ffi.Int()
  external int stream;

  external FT_Module driver;

  @ffi.Int()
  external int num_params;

  external ffi.Pointer<FT_Parameter> params;
}

/// @type:
/// FT_Module
///
/// @description:
/// A handle to a given FreeType module object.  A module can be a font
/// driver, a renderer, or anything else that provides services to the
/// former.
typedef FT_Module = ffi.Pointer<FT_ModuleRec_>;

/// @struct:
/// FT_Parameter
///
/// @description:
/// A simple structure to pass more or less generic parameters to
/// @FT_Open_Face and @FT_Face_Properties.
///
/// @fields:
/// tag ::
/// A four-byte identification tag.
///
/// data ::
/// A pointer to the parameter data.
///
/// @note:
/// The ID and function of parameters are driver-specific.  See section
/// @parameter_tags for more information.
typedef FT_Parameter = FT_Parameter_;

/// @enum:
/// FT_Size_Request_Type
///
/// @description:
/// An enumeration type that lists the supported size request types, i.e.,
/// what input size (in font units) maps to the requested output size (in
/// pixels, as computed from the arguments of @FT_Size_Request).
///
/// @values:
/// FT_SIZE_REQUEST_TYPE_NOMINAL ::
/// The nominal size.  The `units_per_EM` field of @FT_FaceRec is used
/// to determine both scaling values.
///
/// This is the standard scaling found in most applications.  In
/// particular, use this size request type for TrueType fonts if they
/// provide optical scaling or something similar.  Note, however, that
/// `units_per_EM` is a rather abstract value which bears no relation to
/// the actual size of the glyphs in a font.
///
/// FT_SIZE_REQUEST_TYPE_REAL_DIM ::
/// The real dimension.  The sum of the `ascender` and (minus of) the
/// `descender` fields of @FT_FaceRec is used to determine both scaling
/// values.
///
/// FT_SIZE_REQUEST_TYPE_BBOX ::
/// The font bounding box.  The width and height of the `bbox` field of
/// @FT_FaceRec are used to determine the horizontal and vertical
/// scaling value, respectively.
///
/// FT_SIZE_REQUEST_TYPE_CELL ::
/// The `max_advance_width` field of @FT_FaceRec is used to determine
/// the horizontal scaling value; the vertical scaling value is
/// determined the same way as @FT_SIZE_REQUEST_TYPE_REAL_DIM does.
/// Finally, both scaling values are set to the smaller one.  This type
/// is useful if you want to specify the font size for, say, a window of
/// a given dimension and 80x24 cells.
///
/// FT_SIZE_REQUEST_TYPE_SCALES ::
/// Specify the scaling values directly.
///
/// @note:
/// The above descriptions only apply to scalable formats.  For bitmap
/// formats, the behaviour is up to the driver.
///
/// See the note section of @FT_Size_Metrics if you wonder how size
/// requesting relates to scaling values.
abstract class FT_Size_Request_Type_ {
  static const int FT_SIZE_REQUEST_TYPE_NOMINAL = 0;
  static const int FT_SIZE_REQUEST_TYPE_REAL_DIM = 1;
  static const int FT_SIZE_REQUEST_TYPE_BBOX = 2;
  static const int FT_SIZE_REQUEST_TYPE_CELL = 3;
  static const int FT_SIZE_REQUEST_TYPE_SCALES = 4;
  static const int FT_SIZE_REQUEST_TYPE_MAX = 5;
}

/// @struct:
/// FT_Size_RequestRec
///
/// @description:
/// A structure to model a size request.
///
/// @fields:
/// type ::
/// See @FT_Size_Request_Type.
///
/// width ::
/// The desired width, given as a 26.6 fractional point value (with 72pt
/// = 1in).
///
/// height ::
/// The desired height, given as a 26.6 fractional point value (with
/// 72pt = 1in).
///
/// horiResolution ::
/// The horizontal resolution (dpi, i.e., pixels per inch).  If set to
/// zero, `width` is treated as a 26.6 fractional **pixel** value, which
/// gets internally rounded to an integer.
///
/// vertResolution ::
/// The vertical resolution (dpi, i.e., pixels per inch).  If set to
/// zero, `height` is treated as a 26.6 fractional **pixel** value,
/// which gets internally rounded to an integer.
///
/// @note:
/// If `width` is zero, the horizontal scaling value is set equal to the
/// vertical scaling value, and vice versa.
///
/// If `type` is `FT_SIZE_REQUEST_TYPE_SCALES`, `width` and `height` are
/// interpreted directly as 16.16 fractional scaling values, without any
/// further modification, and both `horiResolution` and `vertResolution`
/// are ignored.
final class FT_Size_RequestRec_ extends ffi.Struct {
  @ffi.Int32()
  external int type;

  @ffi.Int()
  external int width;

  @ffi.Int()
  external int height;

  @ffi.Int()
  external int horiResolution;

  @ffi.Int()
  external int vertResolution;
}

/// @enum:
/// FT_Render_Mode
///
/// @description:
/// Render modes supported by FreeType~2.  Each mode corresponds to a
/// specific type of scanline conversion performed on the outline.
///
/// For bitmap fonts and embedded bitmaps the `bitmap->pixel_mode` field
/// in the @FT_GlyphSlotRec structure gives the format of the returned
/// bitmap.
///
/// All modes except @FT_RENDER_MODE_MONO use 256 levels of opacity,
/// indicating pixel coverage.  Use linear alpha blending and gamma
/// correction to correctly render non-monochrome glyph bitmaps onto a
/// surface; see @FT_Render_Glyph.
///
/// The @FT_RENDER_MODE_SDF is a special render mode that uses up to 256
/// distance values, indicating the signed distance from the grid position
/// to the nearest outline.
///
/// @values:
/// FT_RENDER_MODE_NORMAL ::
/// Default render mode; it corresponds to 8-bit anti-aliased bitmaps.
///
/// FT_RENDER_MODE_LIGHT ::
/// This is equivalent to @FT_RENDER_MODE_NORMAL.  It is only defined as
/// a separate value because render modes are also used indirectly to
/// define hinting algorithm selectors.  See @FT_LOAD_TARGET_XXX for
/// details.
///
/// FT_RENDER_MODE_MONO ::
/// This mode corresponds to 1-bit bitmaps (with 2~levels of opacity).
///
/// FT_RENDER_MODE_LCD ::
/// This mode corresponds to horizontal RGB and BGR subpixel displays
/// like LCD screens.  It produces 8-bit bitmaps that are 3~times the
/// width of the original glyph outline in pixels, and which use the
/// @FT_PIXEL_MODE_LCD mode.
///
/// FT_RENDER_MODE_LCD_V ::
/// This mode corresponds to vertical RGB and BGR subpixel displays
/// (like PDA screens, rotated LCD displays, etc.).  It produces 8-bit
/// bitmaps that are 3~times the height of the original glyph outline in
/// pixels and use the @FT_PIXEL_MODE_LCD_V mode.
///
/// FT_RENDER_MODE_SDF ::
/// This mode corresponds to 8-bit, single-channel signed distance field
/// (SDF) bitmaps.  Each pixel in the SDF grid is the value from the
/// pixel's position to the nearest glyph's outline.  The distances are
/// calculated from the center of the pixel and are positive if they are
/// filled by the outline (i.e., inside the outline) and negative
/// otherwise.  Check the note below on how to convert the output values
/// to usable data.
///
/// @note:
/// The selected render mode only affects vector glyphs of a font.
/// Embedded bitmaps often have a different pixel mode like
/// @FT_PIXEL_MODE_MONO.  You can use @FT_Bitmap_Convert to transform them
/// into 8-bit pixmaps.
///
/// For @FT_RENDER_MODE_SDF the output bitmap buffer contains normalized
/// distances that are packed into unsigned 8-bit values.  To get pixel
/// values in floating point representation use the following pseudo-C
/// code for the conversion.
///
/// ```
/// // Load glyph and render using FT_RENDER_MODE_SDF,
/// // then use the output buffer as follows.
///
/// ...
/// FT_Byte  buffer = glyph->bitmap->buffer;
///
///
/// for pixel in buffer
/// {
/// // `sd` is the signed distance and `spread` is the current spread;
/// // the default spread is 2 and can be changed.
///
/// float  sd = (float)pixel - 128.0f;
///
///
/// // Convert to pixel values.
/// sd = ( sd / 128.0f ) * spread;
///
/// // Store `sd` in a buffer or use as required.
/// }
///
/// ```
///
/// FreeType has two rasterizers for generating SDF, namely:
///
/// 1. `sdf` for generating SDF directly from glyph's outline, and
///
/// 2. `bsdf` for generating SDF from rasterized bitmaps.
///
/// Depending on the glyph type (i.e., outline or bitmap), one of the two
/// rasterizers is chosen at runtime and used for generating SDFs.  To
/// force the use of `bsdf` you should render the glyph with any of the
/// FreeType's other rendering modes (e.g., `FT_RENDER_MODE_NORMAL`) and
/// then re-render with `FT_RENDER_MODE_SDF`.
///
/// There are some issues with stability and possible failures of the SDF
/// renderers (specifically `sdf`).
///
/// 1. The `sdf` rasterizer is sensitive to really small features (e.g.,
/// sharp turns that are less than 1~pixel) and imperfections in the
/// glyph's outline, causing artifacts in the final output.
///
/// 2. The `sdf` rasterizer has limited support for handling intersecting
/// contours and *cannot* handle self-intersecting contours whatsoever.
/// Self-intersection happens when a single connected contour
/// intersects itself at some point; having these in your font
/// definitely poses a problem to the rasterizer and cause artifacts,
/// too.
///
/// 3. Generating SDF for really small glyphs may result in undesirable
/// output; the pixel grid (which stores distance information) becomes
/// too coarse.
///
/// 4. Since the output buffer is normalized, precision at smaller spreads
/// is greater than precision at larger spread values because the
/// output range of [0..255] gets mapped to a smaller SDF range.  A
/// spread of~2 should be sufficient in most cases.
///
/// Points (1) and (2) can be avoided by using the `bsdf` rasterizer,
/// which is more stable than the `sdf` rasterizer in general.
abstract class FT_Render_Mode_ {
  static const int FT_RENDER_MODE_NORMAL = 0;
  static const int FT_RENDER_MODE_LIGHT = 1;
  static const int FT_RENDER_MODE_MONO = 2;
  static const int FT_RENDER_MODE_LCD = 3;
  static const int FT_RENDER_MODE_LCD_V = 4;
  static const int FT_RENDER_MODE_SDF = 5;
  static const int FT_RENDER_MODE_MAX = 6;
}

/// @enum:
/// FT_Kerning_Mode
///
/// @description:
/// An enumeration to specify the format of kerning values returned by
/// @FT_Get_Kerning.
///
/// @values:
/// FT_KERNING_DEFAULT ::
/// Return grid-fitted kerning distances in 26.6 fractional pixels.
///
/// FT_KERNING_UNFITTED ::
/// Return un-grid-fitted kerning distances in 26.6 fractional pixels.
///
/// FT_KERNING_UNSCALED ::
/// Return the kerning vector in original font units.
///
/// @note:
/// `FT_KERNING_DEFAULT` returns full pixel values; it also makes FreeType
/// heuristically scale down kerning distances at small ppem values so
/// that they don't become too big.
///
/// Both `FT_KERNING_DEFAULT` and `FT_KERNING_UNFITTED` use the current
/// horizontal scaling factor (as set e.g. with @FT_Set_Char_Size) to
/// convert font units to pixels.
abstract class FT_Kerning_Mode_ {
  static const int FT_KERNING_DEFAULT = 0;
  static const int FT_KERNING_UNFITTED = 1;
  static const int FT_KERNING_UNSCALED = 2;
}

const int ft_encoding_none = 0;

const int ft_encoding_unicode = 2;

const int ft_encoding_symbol = 1;

const int ft_encoding_latin_1 = 11;

const int ft_encoding_latin_2 = 12;

const int ft_encoding_sjis = 3;

const int ft_encoding_gb2312 = 4;

const int ft_encoding_big5 = 5;

const int ft_encoding_wansung = 6;

const int ft_encoding_johab = 7;

const int ft_encoding_adobe_standard = 8;

const int ft_encoding_adobe_expert = 9;

const int ft_encoding_adobe_custom = 10;

const int ft_encoding_apple_roman = 13;

const int FT_FACE_FLAG_SCALABLE = 1;

const int FT_FACE_FLAG_FIXED_SIZES = 2;

const int FT_FACE_FLAG_FIXED_WIDTH = 4;

const int FT_FACE_FLAG_SFNT = 8;

const int FT_FACE_FLAG_HORIZONTAL = 16;

const int FT_FACE_FLAG_VERTICAL = 32;

const int FT_FACE_FLAG_KERNING = 64;

const int FT_FACE_FLAG_FAST_GLYPHS = 128;

const int FT_FACE_FLAG_MULTIPLE_MASTERS = 256;

const int FT_FACE_FLAG_GLYPH_NAMES = 512;

const int FT_FACE_FLAG_EXTERNAL_STREAM = 1024;

const int FT_FACE_FLAG_HINTER = 2048;

const int FT_FACE_FLAG_CID_KEYED = 4096;

const int FT_FACE_FLAG_TRICKY = 8192;

const int FT_FACE_FLAG_COLOR = 16384;

const int FT_FACE_FLAG_VARIATION = 32768;

const int FT_FACE_FLAG_SVG = 65536;

const int FT_FACE_FLAG_SBIX = 131072;

const int FT_FACE_FLAG_SBIX_OVERLAY = 262144;

const int FT_STYLE_FLAG_ITALIC = 1;

const int FT_STYLE_FLAG_BOLD = 2;

const int FT_OPEN_MEMORY = 1;

const int FT_OPEN_STREAM = 2;

const int FT_OPEN_PATHNAME = 4;

const int FT_OPEN_DRIVER = 8;

const int FT_OPEN_PARAMS = 16;

const int ft_open_memory = 1;

const int ft_open_stream = 2;

const int ft_open_pathname = 4;

const int ft_open_driver = 8;

const int ft_open_params = 16;

const int FT_LOAD_DEFAULT = 0;

const int FT_LOAD_NO_SCALE = 1;

const int FT_LOAD_NO_HINTING = 2;

const int FT_LOAD_RENDER = 4;

const int FT_LOAD_NO_BITMAP = 8;

const int FT_LOAD_VERTICAL_LAYOUT = 16;

const int FT_LOAD_FORCE_AUTOHINT = 32;

const int FT_LOAD_CROP_BITMAP = 64;

const int FT_LOAD_PEDANTIC = 128;

const int FT_LOAD_IGNORE_GLOBAL_ADVANCE_WIDTH = 512;

const int FT_LOAD_NO_RECURSE = 1024;

const int FT_LOAD_IGNORE_TRANSFORM = 2048;

const int FT_LOAD_MONOCHROME = 4096;

const int FT_LOAD_LINEAR_DESIGN = 8192;

const int FT_LOAD_SBITS_ONLY = 16384;

const int FT_LOAD_NO_AUTOHINT = 32768;

const int FT_LOAD_COLOR = 1048576;

const int FT_LOAD_COMPUTE_METRICS = 2097152;

const int FT_LOAD_BITMAP_METRICS_ONLY = 4194304;

const int FT_LOAD_NO_SVG = 16777216;

const int FT_LOAD_ADVANCE_ONLY = 256;

const int FT_LOAD_SVG_ONLY = 8388608;

const int ft_render_mode_normal = 0;

const int ft_render_mode_mono = 2;

const int ft_kerning_default = 0;

const int ft_kerning_unfitted = 1;

const int ft_kerning_unscaled = 2;

const int FT_SUBGLYPH_FLAG_ARGS_ARE_WORDS = 1;

const int FT_SUBGLYPH_FLAG_ARGS_ARE_XY_VALUES = 2;

const int FT_SUBGLYPH_FLAG_ROUND_XY_TO_GRID = 4;

const int FT_SUBGLYPH_FLAG_SCALE = 8;

const int FT_SUBGLYPH_FLAG_XY_SCALE = 64;

const int FT_SUBGLYPH_FLAG_2X2 = 128;

const int FT_SUBGLYPH_FLAG_USE_MY_METRICS = 512;

const int FT_FSTYPE_INSTALLABLE_EMBEDDING = 0;

const int FT_FSTYPE_RESTRICTED_LICENSE_EMBEDDING = 2;

const int FT_FSTYPE_PREVIEW_AND_PRINT_EMBEDDING = 4;

const int FT_FSTYPE_EDITABLE_EMBEDDING = 8;

const int FT_FSTYPE_NO_SUBSETTING = 256;

const int FT_FSTYPE_BITMAP_EMBEDDING_ONLY = 512;

const int FREETYPE_MAJOR = 2;

const int FREETYPE_MINOR = 13;

const int FREETYPE_PATCH = 2;
