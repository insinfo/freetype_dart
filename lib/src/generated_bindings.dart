// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// Freetype binding for dart
class FreetypeBinding {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  FreetypeBinding(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  FreetypeBinding.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  /// @function:
  /// FT_Init_FreeType
  ///
  /// @description:
  /// Initialize a new FreeType library object.  The set of modules that are
  /// registered by this function is determined at build time.
  ///
  /// @output:
  /// alibrary ::
  /// A handle to a new library object.
  ///
  /// @return:
  /// FreeType error code.  0~means success.
  ///
  /// @note:
  /// In case you want to provide your own memory allocating routines, use
  /// @FT_New_Library instead, followed by a call to @FT_Add_Default_Modules
  /// (or a series of calls to @FT_Add_Module) and
  /// @FT_Set_Default_Properties.
  ///
  /// See the documentation of @FT_Library and @FT_Face for multi-threading
  /// issues.
  ///
  /// If you need reference-counting (cf. @FT_Reference_Library), use
  /// @FT_New_Library and @FT_Done_Library.
  ///
  /// If compilation option `FT_CONFIG_OPTION_ENVIRONMENT_PROPERTIES` is
  /// set, this function reads the `FREETYPE_PROPERTIES` environment
  /// variable to control driver properties.  See section @properties for
  /// more.
  int FT_Init_FreeType(
    ffi.Pointer<FT_Library> alibrary,
  ) {
    return _FT_Init_FreeType(
      alibrary,
    );
  }

  late final _FT_Init_FreeTypePtr =
      _lookup<ffi.NativeFunction<FT_Error Function(ffi.Pointer<FT_Library>)>>(
          'FT_Init_FreeType');
  late final _FT_Init_FreeType =
      _FT_Init_FreeTypePtr.asFunction<int Function(ffi.Pointer<FT_Library>)>();

  /// @function:
  /// FT_Done_FreeType
  ///
  /// @description:
  /// Destroy a given FreeType library object and all of its children,
  /// including resources, drivers, faces, sizes, etc.
  ///
  /// @input:
  /// library ::
  /// A handle to the target library object.
  ///
  /// @return:
  /// FreeType error code.  0~means success.
  int FT_Done_FreeType(
    FT_Library library1,
  ) {
    return _FT_Done_FreeType(
      library1,
    );
  }

  late final _FT_Done_FreeTypePtr =
      _lookup<ffi.NativeFunction<FT_Error Function(FT_Library)>>(
          'FT_Done_FreeType');
  late final _FT_Done_FreeType =
      _FT_Done_FreeTypePtr.asFunction<int Function(FT_Library)>();

  /// @function:
  /// FT_New_Face
  ///
  /// @description:
  /// Call @FT_Open_Face to open a font by its pathname.
  ///
  /// @inout:
  /// library ::
  /// A handle to the library resource.
  ///
  /// @input:
  /// pathname ::
  /// A path to the font file.
  ///
  /// face_index ::
  /// See @FT_Open_Face for a detailed description of this parameter.
  ///
  /// @output:
  /// aface ::
  /// A handle to a new face object.  If `face_index` is greater than or
  /// equal to zero, it must be non-`NULL`.
  ///
  /// @return:
  /// FreeType error code.  0~means success.
  ///
  /// @note:
  /// The `pathname` string should be recognizable as such by a standard
  /// `fopen` call on your system; in particular, this means that `pathname`
  /// must not contain null bytes.  If that is not sufficient to address all
  /// file name possibilities (for example, to handle wide character file
  /// names on Windows in UTF-16 encoding) you might use @FT_Open_Face to
  /// pass a memory array or a stream object instead.
  ///
  /// Use @FT_Done_Face to destroy the created @FT_Face object (along with
  /// its slot and sizes).
  int FT_New_Face(
    FT_Library library1,
    ffi.Pointer<ffi.Char> filepathname,
    int face_index,
    ffi.Pointer<FT_Face> aface,
  ) {
    return _FT_New_Face(
      library1,
      filepathname,
      face_index,
      aface,
    );
  }

  late final _FT_New_FacePtr = _lookup<
      ffi.NativeFunction<
          FT_Error Function(FT_Library, ffi.Pointer<ffi.Char>, FT_Long,
              ffi.Pointer<FT_Face>)>>('FT_New_Face');
  late final _FT_New_Face = _FT_New_FacePtr.asFunction<
      int Function(
          FT_Library, ffi.Pointer<ffi.Char>, int, ffi.Pointer<FT_Face>)>();

  /// @function:
  /// FT_New_Memory_Face
  ///
  /// @description:
  /// Call @FT_Open_Face to open a font that has been loaded into memory.
  ///
  /// @inout:
  /// library ::
  /// A handle to the library resource.
  ///
  /// @input:
  /// file_base ::
  /// A pointer to the beginning of the font data.
  ///
  /// file_size ::
  /// The size of the memory chunk used by the font data.
  ///
  /// face_index ::
  /// See @FT_Open_Face for a detailed description of this parameter.
  ///
  /// @output:
  /// aface ::
  /// A handle to a new face object.  If `face_index` is greater than or
  /// equal to zero, it must be non-`NULL`.
  ///
  /// @return:
  /// FreeType error code.  0~means success.
  ///
  /// @note:
  /// You must not deallocate the memory before calling @FT_Done_Face.
  int FT_New_Memory_Face(
    FT_Library library1,
    ffi.Pointer<FT_Byte> file_base,
    int file_size,
    int face_index,
    ffi.Pointer<FT_Face> aface,
  ) {
    return _FT_New_Memory_Face(
      library1,
      file_base,
      file_size,
      face_index,
      aface,
    );
  }

  late final _FT_New_Memory_FacePtr = _lookup<
      ffi.NativeFunction<
          FT_Error Function(FT_Library, ffi.Pointer<FT_Byte>, FT_Long, FT_Long,
              ffi.Pointer<FT_Face>)>>('FT_New_Memory_Face');
  late final _FT_New_Memory_Face = _FT_New_Memory_FacePtr.asFunction<
      int Function(
          FT_Library, ffi.Pointer<FT_Byte>, int, int, ffi.Pointer<FT_Face>)>();

  /// @function:
  /// FT_Open_Face
  ///
  /// @description:
  /// Create a face object from a given resource described by @FT_Open_Args.
  ///
  /// @inout:
  /// library ::
  /// A handle to the library resource.
  ///
  /// @input:
  /// args ::
  /// A pointer to an `FT_Open_Args` structure that must be filled by the
  /// caller.
  ///
  /// face_index ::
  /// This field holds two different values.  Bits 0-15 are the index of
  /// the face in the font file (starting with value~0).  Set it to~0 if
  /// there is only one face in the font file.
  ///
  /// [Since 2.6.1] Bits 16-30 are relevant to GX and OpenType variation
  /// fonts only, specifying the named instance index for the current face
  /// index (starting with value~1; value~0 makes FreeType ignore named
  /// instances).  For non-variation fonts, bits 16-30 are ignored.
  /// Assuming that you want to access the third named instance in face~4,
  /// `face_index` should be set to 0x00030004.  If you want to access
  /// face~4 without variation handling, simply set `face_index` to
  /// value~4.
  ///
  /// `FT_Open_Face` and its siblings can be used to quickly check whether
  /// the font format of a given font resource is supported by FreeType.
  /// In general, if the `face_index` argument is negative, the function's
  /// return value is~0 if the font format is recognized, or non-zero
  /// otherwise.  The function allocates a more or less empty face handle
  /// in `*aface` (if `aface` isn't `NULL`); the only two useful fields in
  /// this special case are `face->num_faces` and `face->style_flags`.
  /// For any negative value of `face_index`, `face->num_faces` gives the
  /// number of faces within the font file.  For the negative value
  /// '-(N+1)' (with 'N' a non-negative 16-bit value), bits 16-30 in
  /// `face->style_flags` give the number of named instances in face 'N'
  /// if we have a variation font (or zero otherwise).  After examination,
  /// the returned @FT_Face structure should be deallocated with a call to
  /// @FT_Done_Face.
  ///
  /// @output:
  /// aface ::
  /// A handle to a new face object.  If `face_index` is greater than or
  /// equal to zero, it must be non-`NULL`.
  ///
  /// @return:
  /// FreeType error code.  0~means success.
  ///
  /// @note:
  /// Unlike FreeType 1.x, this function automatically creates a glyph slot
  /// for the face object that can be accessed directly through
  /// `face->glyph`.
  ///
  /// Each new face object created with this function also owns a default
  /// @FT_Size object, accessible as `face->size`.
  ///
  /// One @FT_Library instance can have multiple face objects, that is,
  /// @FT_Open_Face and its siblings can be called multiple times using the
  /// same `library` argument.
  ///
  /// See the discussion of reference counters in the description of
  /// @FT_Reference_Face.
  ///
  /// If `FT_OPEN_STREAM` is set in `args->flags`, the stream in
  /// `args->stream` is automatically closed before this function returns
  /// any error (including `FT_Err_Invalid_Argument`).
  ///
  /// @example:
  /// To loop over all faces, use code similar to the following snippet
  /// (omitting the error handling).
  ///
  /// ```
  /// ...
  /// FT_Face  face;
  /// FT_Long  i, num_faces;
  ///
  ///
  /// error = FT_Open_Face( library, args, -1, &face );
  /// if ( error ) { ... }
  ///
  /// num_faces = face->num_faces;
  /// FT_Done_Face( face );
  ///
  /// for ( i = 0; i < num_faces; i++ )
  /// {
  /// ...
  /// error = FT_Open_Face( library, args, i, &face );
  /// ...
  /// FT_Done_Face( face );
  /// ...
  /// }
  /// ```
  ///
  /// To loop over all valid values for `face_index`, use something similar
  /// to the following snippet, again without error handling.  The code
  /// accesses all faces immediately (thus only a single call of
  /// `FT_Open_Face` within the do-loop), with and without named instances.
  ///
  /// ```
  /// ...
  /// FT_Face  face;
  ///
  /// FT_Long  num_faces     = 0;
  /// FT_Long  num_instances = 0;
  ///
  /// FT_Long  face_idx     = 0;
  /// FT_Long  instance_idx = 0;
  ///
  ///
  /// do
  /// {
  /// FT_Long  id = ( instance_idx << 16 ) + face_idx;
  ///
  ///
  /// error = FT_Open_Face( library, args, id, &face );
  /// if ( error ) { ... }
  ///
  /// num_faces     = face->num_faces;
  /// num_instances = face->style_flags >> 16;
  ///
  /// ...
  ///
  /// FT_Done_Face( face );
  ///
  /// if ( instance_idx < num_instances )
  /// instance_idx++;
  /// else
  /// {
  /// face_idx++;
  /// instance_idx = 0;
  /// }
  ///
  /// } while ( face_idx < num_faces )
  /// ```
  int FT_Open_Face(
    FT_Library library1,
    ffi.Pointer<FT_Open_Args> args,
    int face_index,
    ffi.Pointer<FT_Face> aface,
  ) {
    return _FT_Open_Face(
      library1,
      args,
      face_index,
      aface,
    );
  }

  late final _FT_Open_FacePtr = _lookup<
      ffi.NativeFunction<
          FT_Error Function(FT_Library, ffi.Pointer<FT_Open_Args>, FT_Long,
              ffi.Pointer<FT_Face>)>>('FT_Open_Face');
  late final _FT_Open_Face = _FT_Open_FacePtr.asFunction<
      int Function(
          FT_Library, ffi.Pointer<FT_Open_Args>, int, ffi.Pointer<FT_Face>)>();

  /// @function:
  /// FT_Attach_File
  ///
  /// @description:
  /// Call @FT_Attach_Stream to attach a file.
  ///
  /// @inout:
  /// face ::
  /// The target face object.
  ///
  /// @input:
  /// filepathname ::
  /// The pathname.
  ///
  /// @return:
  /// FreeType error code.  0~means success.
  int FT_Attach_File(
    FT_Face face,
    ffi.Pointer<ffi.Char> filepathname,
  ) {
    return _FT_Attach_File(
      face,
      filepathname,
    );
  }

  late final _FT_Attach_FilePtr = _lookup<
      ffi.NativeFunction<
          FT_Error Function(FT_Face, ffi.Pointer<ffi.Char>)>>('FT_Attach_File');
  late final _FT_Attach_File = _FT_Attach_FilePtr.asFunction<
      int Function(FT_Face, ffi.Pointer<ffi.Char>)>();

  /// @function:
  /// FT_Attach_Stream
  ///
  /// @description:
  /// 'Attach' data to a face object.  Normally, this is used to read
  /// additional information for the face object.  For example, you can
  /// attach an AFM file that comes with a Type~1 font to get the kerning
  /// values and other metrics.
  ///
  /// @inout:
  /// face ::
  /// The target face object.
  ///
  /// @input:
  /// parameters ::
  /// A pointer to @FT_Open_Args that must be filled by the caller.
  ///
  /// @return:
  /// FreeType error code.  0~means success.
  ///
  /// @note:
  /// The meaning of the 'attach' (i.e., what really happens when the new
  /// file is read) is not fixed by FreeType itself.  It really depends on
  /// the font format (and thus the font driver).
  ///
  /// Client applications are expected to know what they are doing when
  /// invoking this function.  Most drivers simply do not implement file or
  /// stream attachments.
  int FT_Attach_Stream(
    FT_Face face,
    ffi.Pointer<FT_Open_Args> parameters,
  ) {
    return _FT_Attach_Stream(
      face,
      parameters,
    );
  }

  late final _FT_Attach_StreamPtr = _lookup<
      ffi.NativeFunction<
          FT_Error Function(
              FT_Face, ffi.Pointer<FT_Open_Args>)>>('FT_Attach_Stream');
  late final _FT_Attach_Stream = _FT_Attach_StreamPtr.asFunction<
      int Function(FT_Face, ffi.Pointer<FT_Open_Args>)>();

  /// @function:
  /// FT_Reference_Face
  ///
  /// @description:
  /// A counter gets initialized to~1 at the time an @FT_Face structure is
  /// created.  This function increments the counter.  @FT_Done_Face then
  /// only destroys a face if the counter is~1, otherwise it simply
  /// decrements the counter.
  ///
  /// This function helps in managing life-cycles of structures that
  /// reference @FT_Face objects.
  ///
  /// @input:
  /// face ::
  /// A handle to a target face object.
  ///
  /// @return:
  /// FreeType error code.  0~means success.
  ///
  /// @since:
  /// 2.4.2
  int FT_Reference_Face(
    FT_Face face,
  ) {
    return _FT_Reference_Face(
      face,
    );
  }

  late final _FT_Reference_FacePtr =
      _lookup<ffi.NativeFunction<FT_Error Function(FT_Face)>>(
          'FT_Reference_Face');
  late final _FT_Reference_Face =
      _FT_Reference_FacePtr.asFunction<int Function(FT_Face)>();

  /// @function:
  /// FT_Done_Face
  ///
  /// @description:
  /// Discard a given face object, as well as all of its child slots and
  /// sizes.
  ///
  /// @input:
  /// face ::
  /// A handle to a target face object.
  ///
  /// @return:
  /// FreeType error code.  0~means success.
  ///
  /// @note:
  /// See the discussion of reference counters in the description of
  /// @FT_Reference_Face.
  int FT_Done_Face(
    FT_Face face,
  ) {
    return _FT_Done_Face(
      face,
    );
  }

  late final _FT_Done_FacePtr =
      _lookup<ffi.NativeFunction<FT_Error Function(FT_Face)>>('FT_Done_Face');
  late final _FT_Done_Face =
      _FT_Done_FacePtr.asFunction<int Function(FT_Face)>();

  /// @function:
  /// FT_Select_Size
  ///
  /// @description:
  /// Select a bitmap strike.  To be more precise, this function sets the
  /// scaling factors of the active @FT_Size object in a face so that
  /// bitmaps from this particular strike are taken by @FT_Load_Glyph and
  /// friends.
  ///
  /// @inout:
  /// face ::
  /// A handle to a target face object.
  ///
  /// @input:
  /// strike_index ::
  /// The index of the bitmap strike in the `available_sizes` field of
  /// @FT_FaceRec structure.
  ///
  /// @return:
  /// FreeType error code.  0~means success.
  ///
  /// @note:
  /// For bitmaps embedded in outline fonts it is common that only a subset
  /// of the available glyphs at a given ppem value is available.  FreeType
  /// silently uses outlines if there is no bitmap for a given glyph index.
  ///
  /// For GX and OpenType variation fonts, a bitmap strike makes sense only
  /// if the default instance is active (that is, no glyph variation takes
  /// place); otherwise, FreeType simply ignores bitmap strikes.  The same
  /// is true for all named instances that are different from the default
  /// instance.
  ///
  /// Don't use this function if you are using the FreeType cache API.
  int FT_Select_Size(
    FT_Face face,
    int strike_index,
  ) {
    return _FT_Select_Size(
      face,
      strike_index,
    );
  }

  late final _FT_Select_SizePtr =
      _lookup<ffi.NativeFunction<FT_Error Function(FT_Face, FT_Int)>>(
          'FT_Select_Size');
  late final _FT_Select_Size =
      _FT_Select_SizePtr.asFunction<int Function(FT_Face, int)>();

  /// @function:
  /// FT_Request_Size
  ///
  /// @description:
  /// Resize the scale of the active @FT_Size object in a face.
  ///
  /// @inout:
  /// face ::
  /// A handle to a target face object.
  ///
  /// @input:
  /// req ::
  /// A pointer to a @FT_Size_RequestRec.
  ///
  /// @return:
  /// FreeType error code.  0~means success.
  ///
  /// @note:
  /// Although drivers may select the bitmap strike matching the request,
  /// you should not rely on this if you intend to select a particular
  /// bitmap strike.  Use @FT_Select_Size instead in that case.
  ///
  /// The relation between the requested size and the resulting glyph size
  /// is dependent entirely on how the size is defined in the source face.
  /// The font designer chooses the final size of each glyph relative to
  /// this size.  For more information refer to
  /// 'https://www.freetype.org/freetype2/docs/glyphs/glyphs-2.html'.
  ///
  /// Contrary to @FT_Set_Char_Size, this function doesn't have special code
  /// to normalize zero-valued widths, heights, or resolutions, which are
  /// treated as @FT_LOAD_NO_SCALE.
  ///
  /// Don't use this function if you are using the FreeType cache API.
  int FT_Request_Size(
    FT_Face face,
    FT_Size_Request req,
  ) {
    return _FT_Request_Size(
      face,
      req,
    );
  }

  late final _FT_Request_SizePtr =
      _lookup<ffi.NativeFunction<FT_Error Function(FT_Face, FT_Size_Request)>>(
          'FT_Request_Size');
  late final _FT_Request_Size =
      _FT_Request_SizePtr.asFunction<int Function(FT_Face, FT_Size_Request)>();

  /// @function:
  /// FT_Set_Char_Size
  ///
  /// @description:
  /// Call @FT_Request_Size to request the nominal size (in points).
  ///
  /// @inout:
  /// face ::
  /// A handle to a target face object.
  ///
  /// @input:
  /// char_width ::
  /// The nominal width, in 26.6 fractional points.
  ///
  /// char_height ::
  /// The nominal height, in 26.6 fractional points.
  ///
  /// horz_resolution ::
  /// The horizontal resolution in dpi.
  ///
  /// vert_resolution ::
  /// The vertical resolution in dpi.
  ///
  /// @return:
  /// FreeType error code.  0~means success.
  ///
  /// @note:
  /// While this function allows fractional points as input values, the
  /// resulting ppem value for the given resolution is always rounded to the
  /// nearest integer.
  ///
  /// If either the character width or height is zero, it is set equal to
  /// the other value.
  ///
  /// If either the horizontal or vertical resolution is zero, it is set
  /// equal to the other value.
  ///
  /// A character width or height smaller than 1pt is set to 1pt; if both
  /// resolution values are zero, they are set to 72dpi.
  ///
  /// Don't use this function if you are using the FreeType cache API.
  int FT_Set_Char_Size(
    FT_Face face,
    int char_width,
    int char_height,
    int horz_resolution,
    int vert_resolution,
  ) {
    return _FT_Set_Char_Size(
      face,
      char_width,
      char_height,
      horz_resolution,
      vert_resolution,
    );
  }

  late final _FT_Set_Char_SizePtr = _lookup<
      ffi.NativeFunction<
          FT_Error Function(FT_Face, FT_F26Dot6, FT_F26Dot6, FT_UInt,
              FT_UInt)>>('FT_Set_Char_Size');
  late final _FT_Set_Char_Size = _FT_Set_Char_SizePtr.asFunction<
      int Function(FT_Face, int, int, int, int)>();

  /// @function:
  /// FT_Set_Pixel_Sizes
  ///
  /// @description:
  /// Call @FT_Request_Size to request the nominal size (in pixels).
  ///
  /// @inout:
  /// face ::
  /// A handle to the target face object.
  ///
  /// @input:
  /// pixel_width ::
  /// The nominal width, in pixels.
  ///
  /// pixel_height ::
  /// The nominal height, in pixels.
  ///
  /// @return:
  /// FreeType error code.  0~means success.
  ///
  /// @note:
  /// You should not rely on the resulting glyphs matching or being
  /// constrained to this pixel size.  Refer to @FT_Request_Size to
  /// understand how requested sizes relate to actual sizes.
  ///
  /// Don't use this function if you are using the FreeType cache API.
  int FT_Set_Pixel_Sizes(
    FT_Face face,
    int pixel_width,
    int pixel_height,
  ) {
    return _FT_Set_Pixel_Sizes(
      face,
      pixel_width,
      pixel_height,
    );
  }

  late final _FT_Set_Pixel_SizesPtr =
      _lookup<ffi.NativeFunction<FT_Error Function(FT_Face, FT_UInt, FT_UInt)>>(
          'FT_Set_Pixel_Sizes');
  late final _FT_Set_Pixel_Sizes =
      _FT_Set_Pixel_SizesPtr.asFunction<int Function(FT_Face, int, int)>();

  /// @function:
  /// FT_Load_Glyph
  ///
  /// @description:
  /// Load a glyph into the glyph slot of a face object.
  ///
  /// @inout:
  /// face ::
  /// A handle to the target face object where the glyph is loaded.
  ///
  /// @input:
  /// glyph_index ::
  /// The index of the glyph in the font file.  For CID-keyed fonts
  /// (either in PS or in CFF format) this argument specifies the CID
  /// value.
  ///
  /// load_flags ::
  /// A flag indicating what to load for this glyph.  The @FT_LOAD_XXX
  /// flags can be used to control the glyph loading process (e.g.,
  /// whether the outline should be scaled, whether to load bitmaps or
  /// not, whether to hint the outline, etc).
  ///
  /// @return:
  /// FreeType error code.  0~means success.
  ///
  /// @note:
  /// For proper scaling and hinting, the active @FT_Size object owned by
  /// the face has to be meaningfully initialized by calling
  /// @FT_Set_Char_Size before this function, for example.  The loaded
  /// glyph may be transformed.  See @FT_Set_Transform for the details.
  ///
  /// For subsetted CID-keyed fonts, `FT_Err_Invalid_Argument` is returned
  /// for invalid CID values (that is, for CID values that don't have a
  /// corresponding glyph in the font).  See the discussion of the
  /// @FT_FACE_FLAG_CID_KEYED flag for more details.
  ///
  /// If you receive `FT_Err_Glyph_Too_Big`, try getting the glyph outline
  /// at EM size, then scale it manually and fill it as a graphics
  /// operation.
  int FT_Load_Glyph(
    FT_Face face,
    int glyph_index,
    int load_flags,
  ) {
    return _FT_Load_Glyph(
      face,
      glyph_index,
      load_flags,
    );
  }

  late final _FT_Load_GlyphPtr = _lookup<
          ffi.NativeFunction<FT_Error Function(FT_Face, FT_UInt, FT_Int32)>>(
      'FT_Load_Glyph');
  late final _FT_Load_Glyph =
      _FT_Load_GlyphPtr.asFunction<int Function(FT_Face, int, int)>();

  /// @function:
  /// FT_Load_Char
  ///
  /// @description:
  /// Load a glyph into the glyph slot of a face object, accessed by its
  /// character code.
  ///
  /// @inout:
  /// face ::
  /// A handle to a target face object where the glyph is loaded.
  ///
  /// @input:
  /// char_code ::
  /// The glyph's character code, according to the current charmap used in
  /// the face.
  ///
  /// load_flags ::
  /// A flag indicating what to load for this glyph.  The @FT_LOAD_XXX
  /// constants can be used to control the glyph loading process (e.g.,
  /// whether the outline should be scaled, whether to load bitmaps or
  /// not, whether to hint the outline, etc).
  ///
  /// @return:
  /// FreeType error code.  0~means success.
  ///
  /// @note:
  /// This function simply calls @FT_Get_Char_Index and @FT_Load_Glyph.
  ///
  /// Many fonts contain glyphs that can't be loaded by this function since
  /// its glyph indices are not listed in any of the font's charmaps.
  ///
  /// If no active cmap is set up (i.e., `face->charmap` is zero), the call
  /// to @FT_Get_Char_Index is omitted, and the function behaves identically
  /// to @FT_Load_Glyph.
  int FT_Load_Char(
    FT_Face face,
    int char_code,
    int load_flags,
  ) {
    return _FT_Load_Char(
      face,
      char_code,
      load_flags,
    );
  }

  late final _FT_Load_CharPtr = _lookup<
          ffi.NativeFunction<FT_Error Function(FT_Face, FT_ULong, FT_Int32)>>(
      'FT_Load_Char');
  late final _FT_Load_Char =
      _FT_Load_CharPtr.asFunction<int Function(FT_Face, int, int)>();

  /// @function:
  /// FT_Set_Transform
  ///
  /// @description:
  /// Set the transformation that is applied to glyph images when they are
  /// loaded into a glyph slot through @FT_Load_Glyph.
  ///
  /// @inout:
  /// face ::
  /// A handle to the source face object.
  ///
  /// @input:
  /// matrix ::
  /// A pointer to the transformation's 2x2 matrix.  Use `NULL` for the
  /// identity matrix.
  /// delta ::
  /// A pointer to the translation vector.  Use `NULL` for the null
  /// vector.
  ///
  /// @note:
  /// This function is provided as a convenience, but keep in mind that
  /// @FT_Matrix coefficients are only 16.16 fixed-point values, which can
  /// limit the accuracy of the results.  Using floating-point computations
  /// to perform the transform directly in client code instead will always
  /// yield better numbers.
  ///
  /// The transformation is only applied to scalable image formats after the
  /// glyph has been loaded.  It means that hinting is unaltered by the
  /// transformation and is performed on the character size given in the
  /// last call to @FT_Set_Char_Size or @FT_Set_Pixel_Sizes.
  ///
  /// Note that this also transforms the `face.glyph.advance` field, but
  /// **not** the values in `face.glyph.metrics`.
  void FT_Set_Transform(
    FT_Face face,
    ffi.Pointer<FT_Matrix> matrix,
    ffi.Pointer<FT_Vector> delta,
  ) {
    return _FT_Set_Transform(
      face,
      matrix,
      delta,
    );
  }

  late final _FT_Set_TransformPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(FT_Face, ffi.Pointer<FT_Matrix>,
              ffi.Pointer<FT_Vector>)>>('FT_Set_Transform');
  late final _FT_Set_Transform = _FT_Set_TransformPtr.asFunction<
      void Function(FT_Face, ffi.Pointer<FT_Matrix>, ffi.Pointer<FT_Vector>)>();

  /// @function:
  /// FT_Get_Transform
  ///
  /// @description:
  /// Return the transformation that is applied to glyph images when they
  /// are loaded into a glyph slot through @FT_Load_Glyph.  See
  /// @FT_Set_Transform for more details.
  ///
  /// @input:
  /// face ::
  /// A handle to the source face object.
  ///
  /// @output:
  /// matrix ::
  /// A pointer to a transformation's 2x2 matrix.  Set this to NULL if you
  /// are not interested in the value.
  ///
  /// delta ::
  /// A pointer to a translation vector.  Set this to NULL if you are not
  /// interested in the value.
  ///
  /// @since:
  /// 2.11
  void FT_Get_Transform(
    FT_Face face,
    ffi.Pointer<FT_Matrix> matrix,
    ffi.Pointer<FT_Vector> delta,
  ) {
    return _FT_Get_Transform(
      face,
      matrix,
      delta,
    );
  }

  late final _FT_Get_TransformPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(FT_Face, ffi.Pointer<FT_Matrix>,
              ffi.Pointer<FT_Vector>)>>('FT_Get_Transform');
  late final _FT_Get_Transform = _FT_Get_TransformPtr.asFunction<
      void Function(FT_Face, ffi.Pointer<FT_Matrix>, ffi.Pointer<FT_Vector>)>();

  /// @function:
  /// FT_Render_Glyph
  ///
  /// @description:
  /// Convert a given glyph image to a bitmap.  It does so by inspecting the
  /// glyph image format, finding the relevant renderer, and invoking it.
  ///
  /// @inout:
  /// slot ::
  /// A handle to the glyph slot containing the image to convert.
  ///
  /// @input:
  /// render_mode ::
  /// The render mode used to render the glyph image into a bitmap.  See
  /// @FT_Render_Mode for a list of possible values.
  ///
  /// If @FT_RENDER_MODE_NORMAL is used, a previous call of @FT_Load_Glyph
  /// with flag @FT_LOAD_COLOR makes `FT_Render_Glyph` provide a default
  /// blending of colored glyph layers associated with the current glyph
  /// slot (provided the font contains such layers) instead of rendering
  /// the glyph slot's outline.  This is an experimental feature; see
  /// @FT_LOAD_COLOR for more information.
  ///
  /// @return:
  /// FreeType error code.  0~means success.
  ///
  /// @note:
  /// When FreeType outputs a bitmap of a glyph, it really outputs an alpha
  /// coverage map.  If a pixel is completely covered by a filled-in
  /// outline, the bitmap contains 0xFF at that pixel, meaning that
  /// 0xFF/0xFF fraction of that pixel is covered, meaning the pixel is 100%
  /// black (or 0% bright).  If a pixel is only 50% covered (value 0x80),
  /// the pixel is made 50% black (50% bright or a middle shade of grey).
  /// 0% covered means 0% black (100% bright or white).
  ///
  /// On high-DPI screens like on smartphones and tablets, the pixels are so
  /// small that their chance of being completely covered and therefore
  /// completely black are fairly good.  On the low-DPI screens, however,
  /// the situation is different.  The pixels are too large for most of the
  /// details of a glyph and shades of gray are the norm rather than the
  /// exception.
  ///
  /// This is relevant because all our screens have a second problem: they
  /// are not linear.  1~+~1 is not~2.  Twice the value does not result in
  /// twice the brightness.  When a pixel is only 50% covered, the coverage
  /// map says 50% black, and this translates to a pixel value of 128 when
  /// you use 8~bits per channel (0-255).  However, this does not translate
  /// to 50% brightness for that pixel on our sRGB and gamma~2.2 screens.
  /// Due to their non-linearity, they dwell longer in the darks and only a
  /// pixel value of about 186 results in 50% brightness -- 128 ends up too
  /// dark on both bright and dark backgrounds.  The net result is that dark
  /// text looks burnt-out, pixely and blotchy on bright background, bright
  /// text too frail on dark backgrounds, and colored text on colored
  /// background (for example, red on green) seems to have dark halos or
  /// 'dirt' around it.  The situation is especially ugly for diagonal stems
  /// like in 'w' glyph shapes where the quality of FreeType's anti-aliasing
  /// depends on the correct display of grays.  On high-DPI screens where
  /// smaller, fully black pixels reign supreme, this doesn't matter, but on
  /// our low-DPI screens with all the gray shades, it does.  0% and 100%
  /// brightness are the same things in linear and non-linear space, just
  /// all the shades in-between aren't.
  ///
  /// The blending function for placing text over a background is
  ///
  /// ```
  /// dst = alpha * src + (1 - alpha) * dst    ,
  /// ```
  ///
  /// which is known as the OVER operator.
  ///
  /// To correctly composite an anti-aliased pixel of a glyph onto a
  /// surface,
  ///
  /// 1. take the foreground and background colors (e.g., in sRGB space)
  /// and apply gamma to get them in a linear space,
  ///
  /// 2. use OVER to blend the two linear colors using the glyph pixel
  /// as the alpha value (remember, the glyph bitmap is an alpha coverage
  /// bitmap), and
  ///
  /// 3. apply inverse gamma to the blended pixel and write it back to
  /// the image.
  ///
  /// Internal testing at Adobe found that a target inverse gamma of~1.8 for
  /// step~3 gives good results across a wide range of displays with an sRGB
  /// gamma curve or a similar one.
  ///
  /// This process can cost performance.  There is an approximation that
  /// does not need to know about the background color; see
  /// https://bel.fi/alankila/lcd/ and
  /// https://bel.fi/alankila/lcd/alpcor.html for details.
  ///
  /// **ATTENTION**: Linear blending is even more important when dealing
  /// with subpixel-rendered glyphs to prevent color-fringing!  A
  /// subpixel-rendered glyph must first be filtered with a filter that
  /// gives equal weight to the three color primaries and does not exceed a
  /// sum of 0x100, see section @lcd_rendering.  Then the only difference to
  /// gray linear blending is that subpixel-rendered linear blending is done
  /// 3~times per pixel: red foreground subpixel to red background subpixel
  /// and so on for green and blue.
  int FT_Render_Glyph(
    FT_GlyphSlot slot,
    int render_mode,
  ) {
    return _FT_Render_Glyph(
      slot,
      render_mode,
    );
  }

  late final _FT_Render_GlyphPtr =
      _lookup<ffi.NativeFunction<FT_Error Function(FT_GlyphSlot, ffi.Int32)>>(
          'FT_Render_Glyph');
  late final _FT_Render_Glyph =
      _FT_Render_GlyphPtr.asFunction<int Function(FT_GlyphSlot, int)>();

  /// @function:
  /// FT_Get_Kerning
  ///
  /// @description:
  /// Return the kerning vector between two glyphs of the same face.
  ///
  /// @input:
  /// face ::
  /// A handle to a source face object.
  ///
  /// left_glyph ::
  /// The index of the left glyph in the kern pair.
  ///
  /// right_glyph ::
  /// The index of the right glyph in the kern pair.
  ///
  /// kern_mode ::
  /// See @FT_Kerning_Mode for more information.  Determines the scale and
  /// dimension of the returned kerning vector.
  ///
  /// @output:
  /// akerning ::
  /// The kerning vector.  This is either in font units, fractional pixels
  /// (26.6 format), or pixels for scalable formats, and in pixels for
  /// fixed-sizes formats.
  ///
  /// @return:
  /// FreeType error code.  0~means success.
  ///
  /// @note:
  /// Only horizontal layouts (left-to-right & right-to-left) are supported
  /// by this method.  Other layouts, or more sophisticated kernings, are
  /// out of the scope of this API function -- they can be implemented
  /// through format-specific interfaces.
  ///
  /// Kerning for OpenType fonts implemented in a 'GPOS' table is not
  /// supported; use @FT_HAS_KERNING to find out whether a font has data
  /// that can be extracted with `FT_Get_Kerning`.
  int FT_Get_Kerning(
    FT_Face face,
    int left_glyph,
    int right_glyph,
    int kern_mode,
    ffi.Pointer<FT_Vector> akerning,
  ) {
    return _FT_Get_Kerning(
      face,
      left_glyph,
      right_glyph,
      kern_mode,
      akerning,
    );
  }

  late final _FT_Get_KerningPtr = _lookup<
      ffi.NativeFunction<
          FT_Error Function(FT_Face, FT_UInt, FT_UInt, FT_UInt,
              ffi.Pointer<FT_Vector>)>>('FT_Get_Kerning');
  late final _FT_Get_Kerning = _FT_Get_KerningPtr.asFunction<
      int Function(FT_Face, int, int, int, ffi.Pointer<FT_Vector>)>();

  /// @function:
  /// FT_Get_Track_Kerning
  ///
  /// @description:
  /// Return the track kerning for a given face object at a given size.
  ///
  /// @input:
  /// face ::
  /// A handle to a source face object.
  ///
  /// point_size ::
  /// The point size in 16.16 fractional points.
  ///
  /// degree ::
  /// The degree of tightness.  Increasingly negative values represent
  /// tighter track kerning, while increasingly positive values represent
  /// looser track kerning.  Value zero means no track kerning.
  ///
  /// @output:
  /// akerning ::
  /// The kerning in 16.16 fractional points, to be uniformly applied
  /// between all glyphs.
  ///
  /// @return:
  /// FreeType error code.  0~means success.
  ///
  /// @note:
  /// Currently, only the Type~1 font driver supports track kerning, using
  /// data from AFM files (if attached with @FT_Attach_File or
  /// @FT_Attach_Stream).
  ///
  /// Only very few AFM files come with track kerning data; please refer to
  /// Adobe's AFM specification for more details.
  int FT_Get_Track_Kerning(
    FT_Face face,
    int point_size,
    int degree,
    ffi.Pointer<FT_Fixed> akerning,
  ) {
    return _FT_Get_Track_Kerning(
      face,
      point_size,
      degree,
      akerning,
    );
  }

  late final _FT_Get_Track_KerningPtr = _lookup<
      ffi.NativeFunction<
          FT_Error Function(FT_Face, FT_Fixed, FT_Int,
              ffi.Pointer<FT_Fixed>)>>('FT_Get_Track_Kerning');
  late final _FT_Get_Track_Kerning = _FT_Get_Track_KerningPtr.asFunction<
      int Function(FT_Face, int, int, ffi.Pointer<FT_Fixed>)>();

  /// @function:
  /// FT_Select_Charmap
  ///
  /// @description:
  /// Select a given charmap by its encoding tag (as listed in
  /// `freetype.h`).
  ///
  /// @inout:
  /// face ::
  /// A handle to the source face object.
  ///
  /// @input:
  /// encoding ::
  /// A handle to the selected encoding.
  ///
  /// @return:
  /// FreeType error code.  0~means success.
  ///
  /// @note:
  /// This function returns an error if no charmap in the face corresponds
  /// to the encoding queried here.
  ///
  /// Because many fonts contain more than a single cmap for Unicode
  /// encoding, this function has some special code to select the one that
  /// covers Unicode best ('best' in the sense that a UCS-4 cmap is
  /// preferred to a UCS-2 cmap).  It is thus preferable to @FT_Set_Charmap
  /// in this case.
  int FT_Select_Charmap(
    FT_Face face,
    int encoding,
  ) {
    return _FT_Select_Charmap(
      face,
      encoding,
    );
  }

  late final _FT_Select_CharmapPtr =
      _lookup<ffi.NativeFunction<FT_Error Function(FT_Face, ffi.Int32)>>(
          'FT_Select_Charmap');
  late final _FT_Select_Charmap =
      _FT_Select_CharmapPtr.asFunction<int Function(FT_Face, int)>();

  /// @function:
  /// FT_Set_Charmap
  ///
  /// @description:
  /// Select a given charmap for character code to glyph index mapping.
  ///
  /// @inout:
  /// face ::
  /// A handle to the source face object.
  ///
  /// @input:
  /// charmap ::
  /// A handle to the selected charmap.
  ///
  /// @return:
  /// FreeType error code.  0~means success.
  ///
  /// @note:
  /// This function returns an error if the charmap is not part of the face
  /// (i.e., if it is not listed in the `face->charmaps` table).
  ///
  /// It also fails if an OpenType type~14 charmap is selected (which
  /// doesn't map character codes to glyph indices at all).
  int FT_Set_Charmap(
    FT_Face face,
    FT_CharMap charmap,
  ) {
    return _FT_Set_Charmap(
      face,
      charmap,
    );
  }

  late final _FT_Set_CharmapPtr =
      _lookup<ffi.NativeFunction<FT_Error Function(FT_Face, FT_CharMap)>>(
          'FT_Set_Charmap');
  late final _FT_Set_Charmap =
      _FT_Set_CharmapPtr.asFunction<int Function(FT_Face, FT_CharMap)>();

  /// @function:
  /// FT_Get_Charmap_Index
  ///
  /// @description:
  /// Retrieve index of a given charmap.
  ///
  /// @input:
  /// charmap ::
  /// A handle to a charmap.
  ///
  /// @return:
  /// The index into the array of character maps within the face to which
  /// `charmap` belongs.  If an error occurs, -1 is returned.
  int FT_Get_Charmap_Index(
    FT_CharMap charmap,
  ) {
    return _FT_Get_Charmap_Index(
      charmap,
    );
  }

  late final _FT_Get_Charmap_IndexPtr =
      _lookup<ffi.NativeFunction<FT_Int Function(FT_CharMap)>>(
          'FT_Get_Charmap_Index');
  late final _FT_Get_Charmap_Index =
      _FT_Get_Charmap_IndexPtr.asFunction<int Function(FT_CharMap)>();

  /// @function:
  /// FT_Get_Char_Index
  ///
  /// @description:
  /// Return the glyph index of a given character code.  This function uses
  /// the currently selected charmap to do the mapping.
  ///
  /// @input:
  /// face ::
  /// A handle to the source face object.
  ///
  /// charcode ::
  /// The character code.
  ///
  /// @return:
  /// The glyph index.  0~means 'undefined character code'.
  ///
  /// @note:
  /// If you use FreeType to manipulate the contents of font files directly,
  /// be aware that the glyph index returned by this function doesn't always
  /// correspond to the internal indices used within the file.  This is done
  /// to ensure that value~0 always corresponds to the 'missing glyph'.  If
  /// the first glyph is not named '.notdef', then for Type~1 and Type~42
  /// fonts, '.notdef' will be moved into the glyph ID~0 position, and
  /// whatever was there will be moved to the position '.notdef' had.  For
  /// Type~1 fonts, if there is no '.notdef' glyph at all, then one will be
  /// created at index~0 and whatever was there will be moved to the last
  /// index -- Type~42 fonts are considered invalid under this condition.
  int FT_Get_Char_Index(
    FT_Face face,
    int charcode,
  ) {
    return _FT_Get_Char_Index(
      face,
      charcode,
    );
  }

  late final _FT_Get_Char_IndexPtr =
      _lookup<ffi.NativeFunction<FT_UInt Function(FT_Face, FT_ULong)>>(
          'FT_Get_Char_Index');
  late final _FT_Get_Char_Index =
      _FT_Get_Char_IndexPtr.asFunction<int Function(FT_Face, int)>();

  /// @function:
  /// FT_Get_First_Char
  ///
  /// @description:
  /// Return the first character code in the current charmap of a given
  /// face, together with its corresponding glyph index.
  ///
  /// @input:
  /// face ::
  /// A handle to the source face object.
  ///
  /// @output:
  /// agindex ::
  /// Glyph index of first character code.  0~if charmap is empty.
  ///
  /// @return:
  /// The charmap's first character code.
  ///
  /// @note:
  /// You should use this function together with @FT_Get_Next_Char to parse
  /// all character codes available in a given charmap.  The code should
  /// look like this:
  ///
  /// ```
  /// FT_ULong  charcode;
  /// FT_UInt   gindex;
  ///
  ///
  /// charcode = FT_Get_First_Char( face, &gindex );
  /// while ( gindex != 0 )
  /// {
  /// ... do something with (charcode,gindex) pair ...
  ///
  /// charcode = FT_Get_Next_Char( face, charcode, &gindex );
  /// }
  /// ```
  ///
  /// Be aware that character codes can have values up to 0xFFFFFFFF; this
  /// might happen for non-Unicode or malformed cmaps.  However, even with
  /// regular Unicode encoding, so-called 'last resort fonts' (using SFNT
  /// cmap format 13, see function @FT_Get_CMap_Format) normally have
  /// entries for all Unicode characters up to 0x1FFFFF, which can cause *a
  /// lot* of iterations.
  ///
  /// Note that `*agindex` is set to~0 if the charmap is empty.  The result
  /// itself can be~0 in two cases: if the charmap is empty or if the
  /// value~0 is the first valid character code.
  int FT_Get_First_Char(
    FT_Face face,
    ffi.Pointer<FT_UInt> agindex,
  ) {
    return _FT_Get_First_Char(
      face,
      agindex,
    );
  }

  late final _FT_Get_First_CharPtr = _lookup<
          ffi.NativeFunction<FT_ULong Function(FT_Face, ffi.Pointer<FT_UInt>)>>(
      'FT_Get_First_Char');
  late final _FT_Get_First_Char = _FT_Get_First_CharPtr.asFunction<
      int Function(FT_Face, ffi.Pointer<FT_UInt>)>();

  /// @function:
  /// FT_Get_Next_Char
  ///
  /// @description:
  /// Return the next character code in the current charmap of a given face
  /// following the value `char_code`, as well as the corresponding glyph
  /// index.
  ///
  /// @input:
  /// face ::
  /// A handle to the source face object.
  ///
  /// char_code ::
  /// The starting character code.
  ///
  /// @output:
  /// agindex ::
  /// Glyph index of next character code.  0~if charmap is empty.
  ///
  /// @return:
  /// The charmap's next character code.
  ///
  /// @note:
  /// You should use this function with @FT_Get_First_Char to walk over all
  /// character codes available in a given charmap.  See the note for that
  /// function for a simple code example.
  ///
  /// Note that `*agindex` is set to~0 when there are no more codes in the
  /// charmap.
  int FT_Get_Next_Char(
    FT_Face face,
    int char_code,
    ffi.Pointer<FT_UInt> agindex,
  ) {
    return _FT_Get_Next_Char(
      face,
      char_code,
      agindex,
    );
  }

  late final _FT_Get_Next_CharPtr = _lookup<
      ffi.NativeFunction<
          FT_ULong Function(
              FT_Face, FT_ULong, ffi.Pointer<FT_UInt>)>>('FT_Get_Next_Char');
  late final _FT_Get_Next_Char = _FT_Get_Next_CharPtr.asFunction<
      int Function(FT_Face, int, ffi.Pointer<FT_UInt>)>();

  /// @function:
  /// FT_Face_Properties
  ///
  /// @description:
  /// Set or override certain (library or module-wide) properties on a
  /// face-by-face basis.  Useful for finer-grained control and avoiding
  /// locks on shared structures (threads can modify their own faces as they
  /// see fit).
  ///
  /// Contrary to @FT_Property_Set, this function uses @FT_Parameter so that
  /// you can pass multiple properties to the target face in one call.  Note
  /// that only a subset of the available properties can be controlled.
  ///
  /// * @FT_PARAM_TAG_STEM_DARKENING (stem darkening, corresponding to the
  /// property `no-stem-darkening` provided by the 'autofit', 'cff',
  /// 'type1', and 't1cid' modules; see @no-stem-darkening).
  ///
  /// * @FT_PARAM_TAG_LCD_FILTER_WEIGHTS (LCD filter weights, corresponding
  /// to function @FT_Library_SetLcdFilterWeights).
  ///
  /// * @FT_PARAM_TAG_RANDOM_SEED (seed value for the CFF, Type~1, and CID
  /// 'random' operator, corresponding to the `random-seed` property
  /// provided by the 'cff', 'type1', and 't1cid' modules; see
  /// @random-seed).
  ///
  /// Pass `NULL` as `data` in @FT_Parameter for a given tag to reset the
  /// option and use the library or module default again.
  ///
  /// @input:
  /// face ::
  /// A handle to the source face object.
  ///
  /// num_properties ::
  /// The number of properties that follow.
  ///
  /// properties ::
  /// A handle to an @FT_Parameter array with `num_properties` elements.
  ///
  /// @return:
  /// FreeType error code.  0~means success.
  ///
  /// @example:
  /// Here is an example that sets three properties.  You must define
  /// `FT_CONFIG_OPTION_SUBPIXEL_RENDERING` to make the LCD filter examples
  /// work.
  ///
  /// ```
  /// FT_Parameter         property1;
  /// FT_Bool              darken_stems = 1;
  ///
  /// FT_Parameter         property2;
  /// FT_LcdFiveTapFilter  custom_weight =
  /// { 0x11, 0x44, 0x56, 0x44, 0x11 };
  ///
  /// FT_Parameter         property3;
  /// FT_Int32             random_seed = 314159265;
  ///
  /// FT_Parameter         properties[3] = { property1,
  /// property2,
  /// property3 };
  ///
  ///
  /// property1.tag  = FT_PARAM_TAG_STEM_DARKENING;
  /// property1.data = &darken_stems;
  ///
  /// property2.tag  = FT_PARAM_TAG_LCD_FILTER_WEIGHTS;
  /// property2.data = custom_weight;
  ///
  /// property3.tag  = FT_PARAM_TAG_RANDOM_SEED;
  /// property3.data = &random_seed;
  ///
  /// FT_Face_Properties( face, 3, properties );
  /// ```
  ///
  /// The next example resets a single property to its default value.
  ///
  /// ```
  /// FT_Parameter  property;
  ///
  ///
  /// property.tag  = FT_PARAM_TAG_LCD_FILTER_WEIGHTS;
  /// property.data = NULL;
  ///
  /// FT_Face_Properties( face, 1, &property );
  /// ```
  ///
  /// @since:
  /// 2.8
  int FT_Face_Properties(
    FT_Face face,
    int num_properties,
    ffi.Pointer<FT_Parameter> properties,
  ) {
    return _FT_Face_Properties(
      face,
      num_properties,
      properties,
    );
  }

  late final _FT_Face_PropertiesPtr = _lookup<
      ffi.NativeFunction<
          FT_Error Function(FT_Face, FT_UInt,
              ffi.Pointer<FT_Parameter>)>>('FT_Face_Properties');
  late final _FT_Face_Properties = _FT_Face_PropertiesPtr.asFunction<
      int Function(FT_Face, int, ffi.Pointer<FT_Parameter>)>();

  /// @function:
  /// FT_Get_Name_Index
  ///
  /// @description:
  /// Return the glyph index of a given glyph name.  This only works
  /// for those faces where @FT_HAS_GLYPH_NAMES returns true.
  ///
  /// @input:
  /// face ::
  /// A handle to the source face object.
  ///
  /// glyph_name ::
  /// The glyph name.
  ///
  /// @return:
  /// The glyph index.  0~means 'undefined character code'.
  ///
  /// @note:
  /// Acceptable glyph names might come from the [Adobe Glyph
  /// List](https://github.com/adobe-type-tools/agl-aglfn).  See
  /// @FT_Get_Glyph_Name for the inverse functionality.
  ///
  /// This function has limited capabilities if the config macro
  /// `FT_CONFIG_OPTION_POSTSCRIPT_NAMES` is not defined in `ftoption.h`:
  /// It then works only for fonts that actually embed glyph names (which
  /// many recent OpenType fonts do not).
  int FT_Get_Name_Index(
    FT_Face face,
    ffi.Pointer<FT_String> glyph_name,
  ) {
    return _FT_Get_Name_Index(
      face,
      glyph_name,
    );
  }

  late final _FT_Get_Name_IndexPtr = _lookup<
          ffi
          .NativeFunction<FT_UInt Function(FT_Face, ffi.Pointer<FT_String>)>>(
      'FT_Get_Name_Index');
  late final _FT_Get_Name_Index = _FT_Get_Name_IndexPtr.asFunction<
      int Function(FT_Face, ffi.Pointer<FT_String>)>();

  /// @function:
  /// FT_Get_Glyph_Name
  ///
  /// @description:
  /// Retrieve the ASCII name of a given glyph in a face.  This only works
  /// for those faces where @FT_HAS_GLYPH_NAMES returns true.
  ///
  /// @input:
  /// face ::
  /// A handle to a source face object.
  ///
  /// glyph_index ::
  /// The glyph index.
  ///
  /// buffer_max ::
  /// The maximum number of bytes available in the buffer.
  ///
  /// @output:
  /// buffer ::
  /// A pointer to a target buffer where the name is copied to.
  ///
  /// @return:
  /// FreeType error code.  0~means success.
  ///
  /// @note:
  /// An error is returned if the face doesn't provide glyph names or if the
  /// glyph index is invalid.  In all cases of failure, the first byte of
  /// `buffer` is set to~0 to indicate an empty name.
  ///
  /// The glyph name is truncated to fit within the buffer if it is too
  /// long.  The returned string is always zero-terminated.
  ///
  /// Be aware that FreeType reorders glyph indices internally so that glyph
  /// index~0 always corresponds to the 'missing glyph' (called '.notdef').
  ///
  /// This function has limited capabilities if the config macro
  /// `FT_CONFIG_OPTION_POSTSCRIPT_NAMES` is not defined in `ftoption.h`:
  /// It then works only for fonts that actually embed glyph names (which
  /// many recent OpenType fonts do not).
  int FT_Get_Glyph_Name(
    FT_Face face,
    int glyph_index,
    FT_Pointer buffer,
    int buffer_max,
  ) {
    return _FT_Get_Glyph_Name(
      face,
      glyph_index,
      buffer,
      buffer_max,
    );
  }

  late final _FT_Get_Glyph_NamePtr = _lookup<
      ffi.NativeFunction<
          FT_Error Function(
              FT_Face, FT_UInt, FT_Pointer, FT_UInt)>>('FT_Get_Glyph_Name');
  late final _FT_Get_Glyph_Name = _FT_Get_Glyph_NamePtr.asFunction<
      int Function(FT_Face, int, FT_Pointer, int)>();

  /// @function:
  /// FT_Get_Postscript_Name
  ///
  /// @description:
  /// Retrieve the ASCII PostScript name of a given face, if available.
  /// This only works with PostScript, TrueType, and OpenType fonts.
  ///
  /// @input:
  /// face ::
  /// A handle to the source face object.
  ///
  /// @return:
  /// A pointer to the face's PostScript name.  `NULL` if unavailable.
  ///
  /// @note:
  /// The returned pointer is owned by the face and is destroyed with it.
  ///
  /// For variation fonts, this string changes if you select a different
  /// instance, and you have to call `FT_Get_PostScript_Name` again to
  /// retrieve it.  FreeType follows Adobe TechNote #5902, 'Generating
  /// PostScript Names for Fonts Using OpenType Font Variations'.
  ///
  /// https://download.macromedia.com/pub/developer/opentype/tech-notes/5902.AdobePSNameGeneration.html
  ///
  /// [Since 2.9] Special PostScript names for named instances are only
  /// returned if the named instance is set with @FT_Set_Named_Instance (and
  /// the font has corresponding entries in its 'fvar' table or is the
  /// default named instance).  If @FT_IS_VARIATION returns true, the
  /// algorithmically derived PostScript name is provided, not looking up
  /// special entries for named instances.
  ffi.Pointer<ffi.Char> FT_Get_Postscript_Name(
    FT_Face face,
  ) {
    return _FT_Get_Postscript_Name(
      face,
    );
  }

  late final _FT_Get_Postscript_NamePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(FT_Face)>>(
          'FT_Get_Postscript_Name');
  late final _FT_Get_Postscript_Name = _FT_Get_Postscript_NamePtr.asFunction<
      ffi.Pointer<ffi.Char> Function(FT_Face)>();

  /// @function:
  /// FT_Get_SubGlyph_Info
  ///
  /// @description:
  /// Retrieve a description of a given subglyph.  Only use it if
  /// `glyph->format` is @FT_GLYPH_FORMAT_COMPOSITE; an error is returned
  /// otherwise.
  ///
  /// @input:
  /// glyph ::
  /// The source glyph slot.
  ///
  /// sub_index ::
  /// The index of the subglyph.  Must be less than
  /// `glyph->num_subglyphs`.
  ///
  /// @output:
  /// p_index ::
  /// The glyph index of the subglyph.
  ///
  /// p_flags ::
  /// The subglyph flags, see @FT_SUBGLYPH_FLAG_XXX.
  ///
  /// p_arg1 ::
  /// The subglyph's first argument (if any).
  ///
  /// p_arg2 ::
  /// The subglyph's second argument (if any).
  ///
  /// p_transform ::
  /// The subglyph transformation (if any).
  ///
  /// @return:
  /// FreeType error code.  0~means success.
  ///
  /// @note:
  /// The values of `*p_arg1`, `*p_arg2`, and `*p_transform` must be
  /// interpreted depending on the flags returned in `*p_flags`.  See the
  /// OpenType specification for details.
  ///
  /// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description
  int FT_Get_SubGlyph_Info(
    FT_GlyphSlot glyph,
    int sub_index,
    ffi.Pointer<FT_Int> p_index,
    ffi.Pointer<FT_UInt> p_flags,
    ffi.Pointer<FT_Int> p_arg1,
    ffi.Pointer<FT_Int> p_arg2,
    ffi.Pointer<FT_Matrix> p_transform,
  ) {
    return _FT_Get_SubGlyph_Info(
      glyph,
      sub_index,
      p_index,
      p_flags,
      p_arg1,
      p_arg2,
      p_transform,
    );
  }

  late final _FT_Get_SubGlyph_InfoPtr = _lookup<
      ffi.NativeFunction<
          FT_Error Function(
              FT_GlyphSlot,
              FT_UInt,
              ffi.Pointer<FT_Int>,
              ffi.Pointer<FT_UInt>,
              ffi.Pointer<FT_Int>,
              ffi.Pointer<FT_Int>,
              ffi.Pointer<FT_Matrix>)>>('FT_Get_SubGlyph_Info');
  late final _FT_Get_SubGlyph_Info = _FT_Get_SubGlyph_InfoPtr.asFunction<
      int Function(FT_GlyphSlot, int, ffi.Pointer<FT_Int>, ffi.Pointer<FT_UInt>,
          ffi.Pointer<FT_Int>, ffi.Pointer<FT_Int>, ffi.Pointer<FT_Matrix>)>();

  /// @function:
  /// FT_Get_FSType_Flags
  ///
  /// @description:
  /// Return the `fsType` flags for a font.
  ///
  /// @input:
  /// face ::
  /// A handle to the source face object.
  ///
  /// @return:
  /// The `fsType` flags, see @FT_FSTYPE_XXX.
  ///
  /// @note:
  /// Use this function rather than directly reading the `fs_type` field in
  /// the @PS_FontInfoRec structure, which is only guaranteed to return the
  /// correct results for Type~1 fonts.
  ///
  /// @since:
  /// 2.3.8
  int FT_Get_FSType_Flags(
    FT_Face face,
  ) {
    return _FT_Get_FSType_Flags(
      face,
    );
  }

  late final _FT_Get_FSType_FlagsPtr =
      _lookup<ffi.NativeFunction<FT_UShort Function(FT_Face)>>(
          'FT_Get_FSType_Flags');
  late final _FT_Get_FSType_Flags =
      _FT_Get_FSType_FlagsPtr.asFunction<int Function(FT_Face)>();

  /// @function:
  /// FT_Face_GetCharVariantIndex
  ///
  /// @description:
  /// Return the glyph index of a given character code as modified by the
  /// variation selector.
  ///
  /// @input:
  /// face ::
  /// A handle to the source face object.
  ///
  /// charcode ::
  /// The character code point in Unicode.
  ///
  /// variantSelector ::
  /// The Unicode code point of the variation selector.
  ///
  /// @return:
  /// The glyph index.  0~means either 'undefined character code', or
  /// 'undefined selector code', or 'no variation selector cmap subtable',
  /// or 'current CharMap is not Unicode'.
  ///
  /// @note:
  /// If you use FreeType to manipulate the contents of font files directly,
  /// be aware that the glyph index returned by this function doesn't always
  /// correspond to the internal indices used within the file.  This is done
  /// to ensure that value~0 always corresponds to the 'missing glyph'.
  ///
  /// This function is only meaningful if
  /// a) the font has a variation selector cmap sub table, and
  /// b) the current charmap has a Unicode encoding.
  ///
  /// @since:
  /// 2.3.6
  int FT_Face_GetCharVariantIndex(
    FT_Face face,
    int charcode,
    int variantSelector,
  ) {
    return _FT_Face_GetCharVariantIndex(
      face,
      charcode,
      variantSelector,
    );
  }

  late final _FT_Face_GetCharVariantIndexPtr = _lookup<
          ffi.NativeFunction<FT_UInt Function(FT_Face, FT_ULong, FT_ULong)>>(
      'FT_Face_GetCharVariantIndex');
  late final _FT_Face_GetCharVariantIndex = _FT_Face_GetCharVariantIndexPtr
      .asFunction<int Function(FT_Face, int, int)>();

  /// @function:
  /// FT_Face_GetCharVariantIsDefault
  ///
  /// @description:
  /// Check whether this variation of this Unicode character is the one to
  /// be found in the charmap.
  ///
  /// @input:
  /// face ::
  /// A handle to the source face object.
  ///
  /// charcode ::
  /// The character codepoint in Unicode.
  ///
  /// variantSelector ::
  /// The Unicode codepoint of the variation selector.
  ///
  /// @return:
  /// 1~if found in the standard (Unicode) cmap, 0~if found in the variation
  /// selector cmap, or -1 if it is not a variation.
  ///
  /// @note:
  /// This function is only meaningful if the font has a variation selector
  /// cmap subtable.
  ///
  /// @since:
  /// 2.3.6
  int FT_Face_GetCharVariantIsDefault(
    FT_Face face,
    int charcode,
    int variantSelector,
  ) {
    return _FT_Face_GetCharVariantIsDefault(
      face,
      charcode,
      variantSelector,
    );
  }

  late final _FT_Face_GetCharVariantIsDefaultPtr =
      _lookup<ffi.NativeFunction<FT_Int Function(FT_Face, FT_ULong, FT_ULong)>>(
          'FT_Face_GetCharVariantIsDefault');
  late final _FT_Face_GetCharVariantIsDefault =
      _FT_Face_GetCharVariantIsDefaultPtr.asFunction<
          int Function(FT_Face, int, int)>();

  /// @function:
  /// FT_Face_GetVariantSelectors
  ///
  /// @description:
  /// Return a zero-terminated list of Unicode variation selectors found in
  /// the font.
  ///
  /// @input:
  /// face ::
  /// A handle to the source face object.
  ///
  /// @return:
  /// A pointer to an array of selector code points, or `NULL` if there is
  /// no valid variation selector cmap subtable.
  ///
  /// @note:
  /// The last item in the array is~0; the array is owned by the @FT_Face
  /// object but can be overwritten or released on the next call to a
  /// FreeType function.
  ///
  /// @since:
  /// 2.3.6
  ffi.Pointer<FT_UInt32> FT_Face_GetVariantSelectors(
    FT_Face face,
  ) {
    return _FT_Face_GetVariantSelectors(
      face,
    );
  }

  late final _FT_Face_GetVariantSelectorsPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<FT_UInt32> Function(FT_Face)>>(
          'FT_Face_GetVariantSelectors');
  late final _FT_Face_GetVariantSelectors = _FT_Face_GetVariantSelectorsPtr
      .asFunction<ffi.Pointer<FT_UInt32> Function(FT_Face)>();

  /// @function:
  /// FT_Face_GetVariantsOfChar
  ///
  /// @description:
  /// Return a zero-terminated list of Unicode variation selectors found for
  /// the specified character code.
  ///
  /// @input:
  /// face ::
  /// A handle to the source face object.
  ///
  /// charcode ::
  /// The character codepoint in Unicode.
  ///
  /// @return:
  /// A pointer to an array of variation selector code points that are
  /// active for the given character, or `NULL` if the corresponding list is
  /// empty.
  ///
  /// @note:
  /// The last item in the array is~0; the array is owned by the @FT_Face
  /// object but can be overwritten or released on the next call to a
  /// FreeType function.
  ///
  /// @since:
  /// 2.3.6
  ffi.Pointer<FT_UInt32> FT_Face_GetVariantsOfChar(
    FT_Face face,
    int charcode,
  ) {
    return _FT_Face_GetVariantsOfChar(
      face,
      charcode,
    );
  }

  late final _FT_Face_GetVariantsOfCharPtr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<FT_UInt32> Function(FT_Face, FT_ULong)>>(
      'FT_Face_GetVariantsOfChar');
  late final _FT_Face_GetVariantsOfChar = _FT_Face_GetVariantsOfCharPtr
      .asFunction<ffi.Pointer<FT_UInt32> Function(FT_Face, int)>();

  /// @function:
  /// FT_Face_GetCharsOfVariant
  ///
  /// @description:
  /// Return a zero-terminated list of Unicode character codes found for the
  /// specified variation selector.
  ///
  /// @input:
  /// face ::
  /// A handle to the source face object.
  ///
  /// variantSelector ::
  /// The variation selector code point in Unicode.
  ///
  /// @return:
  /// A list of all the code points that are specified by this selector
  /// (both default and non-default codes are returned) or `NULL` if there
  /// is no valid cmap or the variation selector is invalid.
  ///
  /// @note:
  /// The last item in the array is~0; the array is owned by the @FT_Face
  /// object but can be overwritten or released on the next call to a
  /// FreeType function.
  ///
  /// @since:
  /// 2.3.6
  ffi.Pointer<FT_UInt32> FT_Face_GetCharsOfVariant(
    FT_Face face,
    int variantSelector,
  ) {
    return _FT_Face_GetCharsOfVariant(
      face,
      variantSelector,
    );
  }

  late final _FT_Face_GetCharsOfVariantPtr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<FT_UInt32> Function(FT_Face, FT_ULong)>>(
      'FT_Face_GetCharsOfVariant');
  late final _FT_Face_GetCharsOfVariant = _FT_Face_GetCharsOfVariantPtr
      .asFunction<ffi.Pointer<FT_UInt32> Function(FT_Face, int)>();

  /// @function:
  /// FT_MulDiv
  ///
  /// @description:
  /// Compute `(a*b)/c` with maximum accuracy, using a 64-bit intermediate
  /// integer whenever necessary.
  ///
  /// This function isn't necessarily as fast as some processor-specific
  /// operations, but is at least completely portable.
  ///
  /// @input:
  /// a ::
  /// The first multiplier.
  ///
  /// b ::
  /// The second multiplier.
  ///
  /// c ::
  /// The divisor.
  ///
  /// @return:
  /// The result of `(a*b)/c`.  This function never traps when trying to
  /// divide by zero; it simply returns 'MaxInt' or 'MinInt' depending on
  /// the signs of `a` and `b`.
  int FT_MulDiv(
    int a,
    int b,
    int c,
  ) {
    return _FT_MulDiv(
      a,
      b,
      c,
    );
  }

  late final _FT_MulDivPtr =
      _lookup<ffi.NativeFunction<FT_Long Function(FT_Long, FT_Long, FT_Long)>>(
          'FT_MulDiv');
  late final _FT_MulDiv =
      _FT_MulDivPtr.asFunction<int Function(int, int, int)>();

  /// @function:
  /// FT_MulFix
  ///
  /// @description:
  /// Compute `(a*b)/0x10000` with maximum accuracy.  Its main use is to
  /// multiply a given value by a 16.16 fixed-point factor.
  ///
  /// @input:
  /// a ::
  /// The first multiplier.
  ///
  /// b ::
  /// The second multiplier.  Use a 16.16 factor here whenever possible
  /// (see note below).
  ///
  /// @return:
  /// The result of `(a*b)/0x10000`.
  ///
  /// @note:
  /// This function has been optimized for the case where the absolute value
  /// of `a` is less than 2048, and `b` is a 16.16 scaling factor.  As this
  /// happens mainly when scaling from notional units to fractional pixels
  /// in FreeType, it resulted in noticeable speed improvements between
  /// versions 2.x and 1.x.
  ///
  /// As a conclusion, always try to place a 16.16 factor as the _second_
  /// argument of this function; this can make a great difference.
  int FT_MulFix(
    int a,
    int b,
  ) {
    return _FT_MulFix(
      a,
      b,
    );
  }

  late final _FT_MulFixPtr =
      _lookup<ffi.NativeFunction<FT_Long Function(FT_Long, FT_Long)>>(
          'FT_MulFix');
  late final _FT_MulFix = _FT_MulFixPtr.asFunction<int Function(int, int)>();

  /// @function:
  /// FT_DivFix
  ///
  /// @description:
  /// Compute `(a*0x10000)/b` with maximum accuracy.  Its main use is to
  /// divide a given value by a 16.16 fixed-point factor.
  ///
  /// @input:
  /// a ::
  /// The numerator.
  ///
  /// b ::
  /// The denominator.  Use a 16.16 factor here.
  ///
  /// @return:
  /// The result of `(a*0x10000)/b`.
  int FT_DivFix(
    int a,
    int b,
  ) {
    return _FT_DivFix(
      a,
      b,
    );
  }

  late final _FT_DivFixPtr =
      _lookup<ffi.NativeFunction<FT_Long Function(FT_Long, FT_Long)>>(
          'FT_DivFix');
  late final _FT_DivFix = _FT_DivFixPtr.asFunction<int Function(int, int)>();

  /// @function:
  /// FT_RoundFix
  ///
  /// @description:
  /// Round a 16.16 fixed number.
  ///
  /// @input:
  /// a ::
  /// The number to be rounded.
  ///
  /// @return:
  /// `a` rounded to the nearest 16.16 fixed integer, halfway cases away
  /// from zero.
  ///
  /// @note:
  /// The function uses wrap-around arithmetic.
  int FT_RoundFix(
    int a,
  ) {
    return _FT_RoundFix(
      a,
    );
  }

  late final _FT_RoundFixPtr =
      _lookup<ffi.NativeFunction<FT_Fixed Function(FT_Fixed)>>('FT_RoundFix');
  late final _FT_RoundFix = _FT_RoundFixPtr.asFunction<int Function(int)>();

  /// @function:
  /// FT_CeilFix
  ///
  /// @description:
  /// Compute the smallest following integer of a 16.16 fixed number.
  ///
  /// @input:
  /// a ::
  /// The number for which the ceiling function is to be computed.
  ///
  /// @return:
  /// `a` rounded towards plus infinity.
  ///
  /// @note:
  /// The function uses wrap-around arithmetic.
  int FT_CeilFix(
    int a,
  ) {
    return _FT_CeilFix(
      a,
    );
  }

  late final _FT_CeilFixPtr =
      _lookup<ffi.NativeFunction<FT_Fixed Function(FT_Fixed)>>('FT_CeilFix');
  late final _FT_CeilFix = _FT_CeilFixPtr.asFunction<int Function(int)>();

  /// @function:
  /// FT_FloorFix
  ///
  /// @description:
  /// Compute the largest previous integer of a 16.16 fixed number.
  ///
  /// @input:
  /// a ::
  /// The number for which the floor function is to be computed.
  ///
  /// @return:
  /// `a` rounded towards minus infinity.
  int FT_FloorFix(
    int a,
  ) {
    return _FT_FloorFix(
      a,
    );
  }

  late final _FT_FloorFixPtr =
      _lookup<ffi.NativeFunction<FT_Fixed Function(FT_Fixed)>>('FT_FloorFix');
  late final _FT_FloorFix = _FT_FloorFixPtr.asFunction<int Function(int)>();

  /// @function:
  /// FT_Vector_Transform
  ///
  /// @description:
  /// Transform a single vector through a 2x2 matrix.
  ///
  /// @inout:
  /// vector ::
  /// The target vector to transform.
  ///
  /// @input:
  /// matrix ::
  /// A pointer to the source 2x2 matrix.
  ///
  /// @note:
  /// The result is undefined if either `vector` or `matrix` is invalid.
  void FT_Vector_Transform(
    ffi.Pointer<FT_Vector> vector,
    ffi.Pointer<FT_Matrix> matrix,
  ) {
    return _FT_Vector_Transform(
      vector,
      matrix,
    );
  }

  late final _FT_Vector_TransformPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<FT_Vector>,
              ffi.Pointer<FT_Matrix>)>>('FT_Vector_Transform');
  late final _FT_Vector_Transform = _FT_Vector_TransformPtr.asFunction<
      void Function(ffi.Pointer<FT_Vector>, ffi.Pointer<FT_Matrix>)>();

  /// @function:
  /// FT_Library_Version
  ///
  /// @description:
  /// Return the version of the FreeType library being used.  This is useful
  /// when dynamically linking to the library, since one cannot use the
  /// macros @FREETYPE_MAJOR, @FREETYPE_MINOR, and @FREETYPE_PATCH.
  ///
  /// @input:
  /// library ::
  /// A source library handle.
  ///
  /// @output:
  /// amajor ::
  /// The major version number.
  ///
  /// aminor ::
  /// The minor version number.
  ///
  /// apatch ::
  /// The patch version number.
  ///
  /// @note:
  /// The reason why this function takes a `library` argument is because
  /// certain programs implement library initialization in a custom way that
  /// doesn't use @FT_Init_FreeType.
  ///
  /// In such cases, the library version might not be available before the
  /// library object has been created.
  void FT_Library_Version(
    FT_Library library1,
    ffi.Pointer<FT_Int> amajor,
    ffi.Pointer<FT_Int> aminor,
    ffi.Pointer<FT_Int> apatch,
  ) {
    return _FT_Library_Version(
      library1,
      amajor,
      aminor,
      apatch,
    );
  }

  late final _FT_Library_VersionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(FT_Library, ffi.Pointer<FT_Int>,
              ffi.Pointer<FT_Int>, ffi.Pointer<FT_Int>)>>('FT_Library_Version');
  late final _FT_Library_Version = _FT_Library_VersionPtr.asFunction<
      void Function(FT_Library, ffi.Pointer<FT_Int>, ffi.Pointer<FT_Int>,
          ffi.Pointer<FT_Int>)>();

  /// @function:
  /// FT_Face_CheckTrueTypePatents
  ///
  /// @description:
  /// Deprecated, does nothing.
  ///
  /// @input:
  /// face ::
  /// A face handle.
  ///
  /// @return:
  /// Always returns false.
  ///
  /// @note:
  /// Since May 2010, TrueType hinting is no longer patented.
  ///
  /// @since:
  /// 2.3.5
  int FT_Face_CheckTrueTypePatents(
    FT_Face face,
  ) {
    return _FT_Face_CheckTrueTypePatents(
      face,
    );
  }

  late final _FT_Face_CheckTrueTypePatentsPtr =
      _lookup<ffi.NativeFunction<FT_Bool Function(FT_Face)>>(
          'FT_Face_CheckTrueTypePatents');
  late final _FT_Face_CheckTrueTypePatents =
      _FT_Face_CheckTrueTypePatentsPtr.asFunction<int Function(FT_Face)>();

  /// @function:
  /// FT_Face_SetUnpatentedHinting
  ///
  /// @description:
  /// Deprecated, does nothing.
  ///
  /// @input:
  /// face ::
  /// A face handle.
  ///
  /// value ::
  /// New boolean setting.
  ///
  /// @return:
  /// Always returns false.
  ///
  /// @note:
  /// Since May 2010, TrueType hinting is no longer patented.
  ///
  /// @since:
  /// 2.3.5
  int FT_Face_SetUnpatentedHinting(
    FT_Face face,
    int value,
  ) {
    return _FT_Face_SetUnpatentedHinting(
      face,
      value,
    );
  }

  late final _FT_Face_SetUnpatentedHintingPtr =
      _lookup<ffi.NativeFunction<FT_Bool Function(FT_Face, FT_Bool)>>(
          'FT_Face_SetUnpatentedHinting');
  late final _FT_Face_SetUnpatentedHinting =
      _FT_Face_SetUnpatentedHintingPtr.asFunction<int Function(FT_Face, int)>();
}

/// @struct:
/// FT_Glyph_Metrics
///
/// @description:
/// A structure to model the metrics of a single glyph.  The values are
/// expressed in 26.6 fractional pixel format; if the flag
/// @FT_LOAD_NO_SCALE has been used while loading the glyph, values are
/// expressed in font units instead.
///
/// @fields:
/// width ::
/// The glyph's width.
///
/// height ::
/// The glyph's height.
///
/// horiBearingX ::
/// Left side bearing for horizontal layout.
///
/// horiBearingY ::
/// Top side bearing for horizontal layout.
///
/// horiAdvance ::
/// Advance width for horizontal layout.
///
/// vertBearingX ::
/// Left side bearing for vertical layout.
///
/// vertBearingY ::
/// Top side bearing for vertical layout.  Larger positive values mean
/// further below the vertical glyph origin.
///
/// vertAdvance ::
/// Advance height for vertical layout.  Positive values mean the glyph
/// has a positive advance downward.
///
/// @note:
/// If not disabled with @FT_LOAD_NO_HINTING, the values represent
/// dimensions of the hinted glyph (in case hinting is applicable).
///
/// Stroking a glyph with an outside border does not increase
/// `horiAdvance` or `vertAdvance`; you have to manually adjust these
/// values to account for the added width and height.
///
/// FreeType doesn't use the 'VORG' table data for CFF fonts because it
/// doesn't have an interface to quickly retrieve the glyph height.  The
/// y~coordinate of the vertical origin can be simply computed as
/// `vertBearingY + height` after loading a glyph.
final class FT_Glyph_Metrics_ extends ffi.Struct {
  @FT_Pos()
  external int width;

  @FT_Pos()
  external int height;

  @FT_Pos()
  external int horiBearingX;

  @FT_Pos()
  external int horiBearingY;

  @FT_Pos()
  external int horiAdvance;

  @FT_Pos()
  external int vertBearingX;

  @FT_Pos()
  external int vertBearingY;

  @FT_Pos()
  external int vertAdvance;
}

/// @type:
/// FT_Pos
///
/// @description:
/// The type FT_Pos is used to store vectorial coordinates.  Depending on
/// the context, these can represent distances in integer font units, or
/// 16.16, or 26.6 fixed-point pixel coordinates.
typedef FT_Pos = ffi.Long;
typedef DartFT_Pos = int;

/// @struct:
/// FT_Bitmap_Size
///
/// @description:
/// This structure models the metrics of a bitmap strike (i.e., a set of
/// glyphs for a given point size and resolution) in a bitmap font.  It is
/// used for the `available_sizes` field of @FT_Face.
///
/// @fields:
/// height ::
/// The vertical distance, in pixels, between two consecutive baselines.
/// It is always positive.
///
/// width ::
/// The average width, in pixels, of all glyphs in the strike.
///
/// size ::
/// The nominal size of the strike in 26.6 fractional points.  This
/// field is not very useful.
///
/// x_ppem ::
/// The horizontal ppem (nominal width) in 26.6 fractional pixels.
///
/// y_ppem ::
/// The vertical ppem (nominal height) in 26.6 fractional pixels.
///
/// @note:
/// Windows FNT:
/// The nominal size given in a FNT font is not reliable.  If the driver
/// finds it incorrect, it sets `size` to some calculated values, and
/// `x_ppem` and `y_ppem` to the pixel width and height given in the
/// font, respectively.
///
/// TrueType embedded bitmaps:
/// `size`, `width`, and `height` values are not contained in the bitmap
/// strike itself.  They are computed from the global font parameters.
final class FT_Bitmap_Size_ extends ffi.Struct {
  @FT_Short()
  external int height;

  @FT_Short()
  external int width;

  @FT_Pos()
  external int size;

  @FT_Pos()
  external int x_ppem;

  @FT_Pos()
  external int y_ppem;
}

/// @type:
/// FT_Short
///
/// @description:
/// A typedef for signed short.
typedef FT_Short = ffi.Short;
typedef DartFT_Short = int;

final class FT_LibraryRec_ extends ffi.Opaque {}

final class FT_ModuleRec_ extends ffi.Opaque {}

final class FT_DriverRec_ extends ffi.Opaque {}

final class FT_RendererRec_ extends ffi.Opaque {}

/// @struct:
/// FT_FaceRec
///
/// @description:
/// FreeType root face class structure.  A face object models a typeface
/// in a font file.
///
/// @fields:
/// num_faces ::
/// The number of faces in the font file.  Some font formats can have
/// multiple faces in a single font file.
///
/// face_index ::
/// This field holds two different values.  Bits 0-15 are the index of
/// the face in the font file (starting with value~0).  They are set
/// to~0 if there is only one face in the font file.
///
/// [Since 2.6.1] Bits 16-30 are relevant to GX and OpenType variation
/// fonts only, holding the named instance index for the current face
/// index (starting with value~1; value~0 indicates font access without
/// a named instance).  For non-variation fonts, bits 16-30 are ignored.
/// If we have the third named instance of face~4, say, `face_index` is
/// set to 0x00030004.
///
/// Bit 31 is always zero (that is, `face_index` is always a positive
/// value).
///
/// [Since 2.9] Changing the design coordinates with
/// @FT_Set_Var_Design_Coordinates or @FT_Set_Var_Blend_Coordinates does
/// not influence the named instance index value (only
/// @FT_Set_Named_Instance does that).
///
/// face_flags ::
/// A set of bit flags that give important information about the face;
/// see @FT_FACE_FLAG_XXX for the details.
///
/// style_flags ::
/// The lower 16~bits contain a set of bit flags indicating the style of
/// the face; see @FT_STYLE_FLAG_XXX for the details.
///
/// [Since 2.6.1] Bits 16-30 hold the number of named instances
/// available for the current face if we have a GX or OpenType variation
/// (sub)font.  Bit 31 is always zero (that is, `style_flags` is always
/// a positive value).  Note that a variation font has always at least
/// one named instance, namely the default instance.
///
/// num_glyphs ::
/// The number of glyphs in the face.  If the face is scalable and has
/// sbits (see `num_fixed_sizes`), it is set to the number of outline
/// glyphs.
///
/// For CID-keyed fonts (not in an SFNT wrapper) this value gives the
/// highest CID used in the font.
///
/// family_name ::
/// The face's family name.  This is an ASCII string, usually in
/// English, that describes the typeface's family (like 'Times New
/// Roman', 'Bodoni', 'Garamond', etc).  This is a least common
/// denominator used to list fonts.  Some formats (TrueType & OpenType)
/// provide localized and Unicode versions of this string.  Applications
/// should use the format-specific interface to access them.  Can be
/// `NULL` (e.g., in fonts embedded in a PDF file).
///
/// In case the font doesn't provide a specific family name entry,
/// FreeType tries to synthesize one, deriving it from other name
/// entries.
///
/// style_name ::
/// The face's style name.  This is an ASCII string, usually in English,
/// that describes the typeface's style (like 'Italic', 'Bold',
/// 'Condensed', etc).  Not all font formats provide a style name, so
/// this field is optional, and can be set to `NULL`.  As for
/// `family_name`, some formats provide localized and Unicode versions
/// of this string.  Applications should use the format-specific
/// interface to access them.
///
/// num_fixed_sizes ::
/// The number of bitmap strikes in the face.  Even if the face is
/// scalable, there might still be bitmap strikes, which are called
/// 'sbits' in that case.
///
/// available_sizes ::
/// An array of @FT_Bitmap_Size for all bitmap strikes in the face.  It
/// is set to `NULL` if there is no bitmap strike.
///
/// Note that FreeType tries to sanitize the strike data since they are
/// sometimes sloppy or incorrect, but this can easily fail.
///
/// num_charmaps ::
/// The number of charmaps in the face.
///
/// charmaps ::
/// An array of the charmaps of the face.
///
/// generic ::
/// A field reserved for client uses.  See the @FT_Generic type
/// description.
///
/// bbox ::
/// The font bounding box.  Coordinates are expressed in font units (see
/// `units_per_EM`).  The box is large enough to contain any glyph from
/// the font.  Thus, `bbox.yMax` can be seen as the 'maximum ascender',
/// and `bbox.yMin` as the 'minimum descender'.  Only relevant for
/// scalable formats.
///
/// Note that the bounding box might be off by (at least) one pixel for
/// hinted fonts.  See @FT_Size_Metrics for further discussion.
///
/// Note that the bounding box does not vary in OpenType variation fonts
/// and should only be used in relation to the default instance.
///
/// units_per_EM ::
/// The number of font units per EM square for this face.  This is
/// typically 2048 for TrueType fonts, and 1000 for Type~1 fonts.  Only
/// relevant for scalable formats.
///
/// ascender ::
/// The typographic ascender of the face, expressed in font units.  For
/// font formats not having this information, it is set to `bbox.yMax`.
/// Only relevant for scalable formats.
///
/// descender ::
/// The typographic descender of the face, expressed in font units.  For
/// font formats not having this information, it is set to `bbox.yMin`.
/// Note that this field is negative for values below the baseline.
/// Only relevant for scalable formats.
///
/// height ::
/// This value is the vertical distance between two consecutive
/// baselines, expressed in font units.  It is always positive.  Only
/// relevant for scalable formats.
///
/// If you want the global glyph height, use `ascender - descender`.
///
/// max_advance_width ::
/// The maximum advance width, in font units, for all glyphs in this
/// face.  This can be used to make word wrapping computations faster.
/// Only relevant for scalable formats.
///
/// max_advance_height ::
/// The maximum advance height, in font units, for all glyphs in this
/// face.  This is only relevant for vertical layouts, and is set to
/// `height` for fonts that do not provide vertical metrics.  Only
/// relevant for scalable formats.
///
/// underline_position ::
/// The position, in font units, of the underline line for this face.
/// It is the center of the underlining stem.  Only relevant for
/// scalable formats.
///
/// underline_thickness ::
/// The thickness, in font units, of the underline for this face.  Only
/// relevant for scalable formats.
///
/// glyph ::
/// The face's associated glyph slot(s).
///
/// size ::
/// The current active size for this face.
///
/// charmap ::
/// The current active charmap for this face.
///
/// @note:
/// Fields may be changed after a call to @FT_Attach_File or
/// @FT_Attach_Stream.
///
/// For an OpenType variation font, the values of the following fields can
/// change after a call to @FT_Set_Var_Design_Coordinates (and friends) if
/// the font contains an 'MVAR' table: `ascender`, `descender`, `height`,
/// `underline_position`, and `underline_thickness`.
///
/// Especially for TrueType fonts see also the documentation for
/// @FT_Size_Metrics.
final class FT_FaceRec_ extends ffi.Struct {
  @FT_Long()
  external int num_faces;

  @FT_Long()
  external int face_index;

  @FT_Long()
  external int face_flags;

  @FT_Long()
  external int style_flags;

  @FT_Long()
  external int num_glyphs;

  external ffi.Pointer<FT_String> family_name;

  external ffi.Pointer<FT_String> style_name;

  @FT_Int()
  external int num_fixed_sizes;

  external ffi.Pointer<FT_Bitmap_Size> available_sizes;

  @FT_Int()
  external int num_charmaps;

  external ffi.Pointer<FT_CharMap> charmaps;

  external FT_Generic generic;

  external FT_BBox bbox;

  @FT_UShort()
  external int units_per_EM;

  @FT_Short()
  external int ascender;

  @FT_Short()
  external int descender;

  @FT_Short()
  external int height;

  @FT_Short()
  external int max_advance_width;

  @FT_Short()
  external int max_advance_height;

  @FT_Short()
  external int underline_position;

  @FT_Short()
  external int underline_thickness;

  external FT_GlyphSlot glyph;

  external FT_Size size;

  external FT_CharMap charmap;

  external FT_Driver driver;

  external FT_Memory memory;

  external FT_Stream stream;

  external FT_ListRec sizes_list;

  external FT_Generic autohint;

  external ffi.Pointer<ffi.Void> extensions;

  external FT_Face_Internal internal;
}

/// @type:
/// FT_Long
///
/// @description:
/// A typedef for signed long.
typedef FT_Long = ffi.Long;
typedef DartFT_Long = int;

/// @type:
/// FT_String
///
/// @description:
/// A simple typedef for the char type, usually used for strings.
typedef FT_String = ffi.Char;
typedef DartFT_String = int;

/// @type:
/// FT_Int
///
/// @description:
/// A typedef for the int type.
typedef FT_Int = ffi.Int;
typedef DartFT_Int = int;

/// @struct:
/// FT_Bitmap_Size
///
/// @description:
/// This structure models the metrics of a bitmap strike (i.e., a set of
/// glyphs for a given point size and resolution) in a bitmap font.  It is
/// used for the `available_sizes` field of @FT_Face.
///
/// @fields:
/// height ::
/// The vertical distance, in pixels, between two consecutive baselines.
/// It is always positive.
///
/// width ::
/// The average width, in pixels, of all glyphs in the strike.
///
/// size ::
/// The nominal size of the strike in 26.6 fractional points.  This
/// field is not very useful.
///
/// x_ppem ::
/// The horizontal ppem (nominal width) in 26.6 fractional pixels.
///
/// y_ppem ::
/// The vertical ppem (nominal height) in 26.6 fractional pixels.
///
/// @note:
/// Windows FNT:
/// The nominal size given in a FNT font is not reliable.  If the driver
/// finds it incorrect, it sets `size` to some calculated values, and
/// `x_ppem` and `y_ppem` to the pixel width and height given in the
/// font, respectively.
///
/// TrueType embedded bitmaps:
/// `size`, `width`, and `height` values are not contained in the bitmap
/// strike itself.  They are computed from the global font parameters.
typedef FT_Bitmap_Size = FT_Bitmap_Size_;

/// @type:
/// FT_CharMap
///
/// @description:
/// A handle to a character map (usually abbreviated to 'charmap').  A
/// charmap is used to translate character codes in a given encoding into
/// glyph indexes for its parent's face.  Some font formats may provide
/// several charmaps per font.
///
/// Each face object owns zero or more charmaps, but only one of them can
/// be 'active', providing the data used by @FT_Get_Char_Index or
/// @FT_Load_Char.
///
/// The list of available charmaps in a face is available through the
/// `face->num_charmaps` and `face->charmaps` fields of @FT_FaceRec.
///
/// The currently active charmap is available as `face->charmap`.  You
/// should call @FT_Set_Charmap to change it.
///
/// @note:
/// When a new face is created (either through @FT_New_Face or
/// @FT_Open_Face), the library looks for a Unicode charmap within the
/// list and automatically activates it.  If there is no Unicode charmap,
/// FreeType doesn't set an 'active' charmap.
///
/// @also:
/// See @FT_CharMapRec for the publicly accessible fields of a given
/// character map.
typedef FT_CharMap = ffi.Pointer<FT_CharMapRec_>;

/// @struct:
/// FT_CharMapRec
///
/// @description:
/// The base charmap structure.
///
/// @fields:
/// face ::
/// A handle to the parent face object.
///
/// encoding ::
/// An @FT_Encoding tag identifying the charmap.  Use this with
/// @FT_Select_Charmap.
///
/// platform_id ::
/// An ID number describing the platform for the following encoding ID.
/// This comes directly from the TrueType specification and gets
/// emulated for other formats.
///
/// encoding_id ::
/// A platform-specific encoding number.  This also comes from the
/// TrueType specification and gets emulated similarly.
final class FT_CharMapRec_ extends ffi.Struct {
  external FT_Face face;

  @ffi.Int32()
  external int encoding;

  @FT_UShort()
  external int platform_id;

  @FT_UShort()
  external int encoding_id;
}

/// @type:
/// FT_Face
///
/// @description:
/// A handle to a typographic face object.  A face object models a given
/// typeface, in a given style.
///
/// @note:
/// A face object also owns a single @FT_GlyphSlot object, as well as one
/// or more @FT_Size objects.
///
/// Use @FT_New_Face or @FT_Open_Face to create a new face object from a
/// given filepath or a custom input stream.
///
/// Use @FT_Done_Face to destroy it (along with its slot and sizes).
///
/// An `FT_Face` object can only be safely used from one thread at a time.
/// Similarly, creation and destruction of `FT_Face` with the same
/// @FT_Library object can only be done from one thread at a time.  On the
/// other hand, functions like @FT_Load_Glyph and its siblings are
/// thread-safe and do not need the lock to be held as long as the same
/// `FT_Face` object is not used from multiple threads at the same time.
///
/// @also:
/// See @FT_FaceRec for the publicly accessible fields of a given face
/// object.
typedef FT_Face = ffi.Pointer<FT_FaceRec_>;

/// @enum:
/// FT_Encoding
///
/// @description:
/// An enumeration to specify character sets supported by charmaps.  Used
/// in the @FT_Select_Charmap API function.
///
/// @note:
/// Despite the name, this enumeration lists specific character
/// repertoires (i.e., charsets), and not text encoding methods (e.g.,
/// UTF-8, UTF-16, etc.).
///
/// Other encodings might be defined in the future.
///
/// @values:
/// FT_ENCODING_NONE ::
/// The encoding value~0 is reserved for all formats except BDF, PCF,
/// and Windows FNT; see below for more information.
///
/// FT_ENCODING_UNICODE ::
/// The Unicode character set.  This value covers all versions of the
/// Unicode repertoire, including ASCII and Latin-1.  Most fonts include
/// a Unicode charmap, but not all of them.
///
/// For example, if you want to access Unicode value U+1F028 (and the
/// font contains it), use value 0x1F028 as the input value for
/// @FT_Get_Char_Index.
///
/// FT_ENCODING_MS_SYMBOL ::
/// Microsoft Symbol encoding, used to encode mathematical symbols and
/// wingdings.  For more information, see
/// 'https://www.microsoft.com/typography/otspec/recom.htm#non-standard-symbol-fonts',
/// 'http://www.kostis.net/charsets/symbol.htm', and
/// 'http://www.kostis.net/charsets/wingding.htm'.
///
/// This encoding uses character codes from the PUA (Private Unicode
/// Area) in the range U+F020-U+F0FF.
///
/// FT_ENCODING_SJIS ::
/// Shift JIS encoding for Japanese.  More info at
/// 'https://en.wikipedia.org/wiki/Shift_JIS'.  See note on multi-byte
/// encodings below.
///
/// FT_ENCODING_PRC ::
/// Corresponds to encoding systems mainly for Simplified Chinese as
/// used in People's Republic of China (PRC).  The encoding layout is
/// based on GB~2312 and its supersets GBK and GB~18030.
///
/// FT_ENCODING_BIG5 ::
/// Corresponds to an encoding system for Traditional Chinese as used in
/// Taiwan and Hong Kong.
///
/// FT_ENCODING_WANSUNG ::
/// Corresponds to the Korean encoding system known as Extended Wansung
/// (MS Windows code page 949).  For more information see
/// 'https://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WindowsBestFit/bestfit949.txt'.
///
/// FT_ENCODING_JOHAB ::
/// The Korean standard character set (KS~C 5601-1992), which
/// corresponds to MS Windows code page 1361.  This character set
/// includes all possible Hangul character combinations.
///
/// FT_ENCODING_ADOBE_LATIN_1 ::
/// Corresponds to a Latin-1 encoding as defined in a Type~1 PostScript
/// font.  It is limited to 256 character codes.
///
/// FT_ENCODING_ADOBE_STANDARD ::
/// Adobe Standard encoding, as found in Type~1, CFF, and OpenType/CFF
/// fonts.  It is limited to 256 character codes.
///
/// FT_ENCODING_ADOBE_EXPERT ::
/// Adobe Expert encoding, as found in Type~1, CFF, and OpenType/CFF
/// fonts.  It is limited to 256 character codes.
///
/// FT_ENCODING_ADOBE_CUSTOM ::
/// Corresponds to a custom encoding, as found in Type~1, CFF, and
/// OpenType/CFF fonts.  It is limited to 256 character codes.
///
/// FT_ENCODING_APPLE_ROMAN ::
/// Apple roman encoding.  Many TrueType and OpenType fonts contain a
/// charmap for this 8-bit encoding, since older versions of Mac OS are
/// able to use it.
///
/// FT_ENCODING_OLD_LATIN_2 ::
/// This value is deprecated and was neither used nor reported by
/// FreeType.  Don't use or test for it.
///
/// FT_ENCODING_MS_SJIS ::
/// Same as FT_ENCODING_SJIS.  Deprecated.
///
/// FT_ENCODING_MS_GB2312 ::
/// Same as FT_ENCODING_PRC.  Deprecated.
///
/// FT_ENCODING_MS_BIG5 ::
/// Same as FT_ENCODING_BIG5.  Deprecated.
///
/// FT_ENCODING_MS_WANSUNG ::
/// Same as FT_ENCODING_WANSUNG.  Deprecated.
///
/// FT_ENCODING_MS_JOHAB ::
/// Same as FT_ENCODING_JOHAB.  Deprecated.
///
/// @note:
/// When loading a font, FreeType makes a Unicode charmap active if
/// possible (either if the font provides such a charmap, or if FreeType
/// can synthesize one from PostScript glyph name dictionaries; in either
/// case, the charmap is tagged with `FT_ENCODING_UNICODE`).  If such a
/// charmap is synthesized, it is placed at the first position of the
/// charmap array.
///
/// All other encodings are considered legacy and tagged only if
/// explicitly defined in the font file.  Otherwise, `FT_ENCODING_NONE` is
/// used.
///
/// `FT_ENCODING_NONE` is set by the BDF and PCF drivers if the charmap is
/// neither Unicode nor ISO-8859-1 (otherwise it is set to
/// `FT_ENCODING_UNICODE`).  Use @FT_Get_BDF_Charset_ID to find out which
/// encoding is really present.  If, for example, the `cs_registry` field
/// is 'KOI8' and the `cs_encoding` field is 'R', the font is encoded in
/// KOI8-R.
///
/// `FT_ENCODING_NONE` is always set (with a single exception) by the
/// winfonts driver.  Use @FT_Get_WinFNT_Header and examine the `charset`
/// field of the @FT_WinFNT_HeaderRec structure to find out which encoding
/// is really present.  For example, @FT_WinFNT_ID_CP1251 (204) means
/// Windows code page 1251 (for Russian).
///
/// `FT_ENCODING_NONE` is set if `platform_id` is @TT_PLATFORM_MACINTOSH
/// and `encoding_id` is not `TT_MAC_ID_ROMAN` (otherwise it is set to
/// `FT_ENCODING_APPLE_ROMAN`).
///
/// If `platform_id` is @TT_PLATFORM_MACINTOSH, use the function
/// @FT_Get_CMap_Language_ID to query the Mac language ID that may be
/// needed to be able to distinguish Apple encoding variants.  See
///
/// https://www.unicode.org/Public/MAPPINGS/VENDORS/APPLE/Readme.txt
///
/// to get an idea how to do that.  Basically, if the language ID is~0,
/// don't use it, otherwise subtract 1 from the language ID.  Then examine
/// `encoding_id`.  If, for example, `encoding_id` is `TT_MAC_ID_ROMAN`
/// and the language ID (minus~1) is `TT_MAC_LANGID_GREEK`, it is the
/// Greek encoding, not Roman.  `TT_MAC_ID_ARABIC` with
/// `TT_MAC_LANGID_FARSI` means the Farsi variant of the Arabic encoding.
abstract class FT_Encoding_ {
  static const int FT_ENCODING_NONE = 0;
  static const int FT_ENCODING_MS_SYMBOL = 1937337698;
  static const int FT_ENCODING_UNICODE = 1970170211;
  static const int FT_ENCODING_SJIS = 1936353651;
  static const int FT_ENCODING_PRC = 1734484000;
  static const int FT_ENCODING_BIG5 = 1651074869;
  static const int FT_ENCODING_WANSUNG = 2002873971;
  static const int FT_ENCODING_JOHAB = 1785686113;
  static const int FT_ENCODING_GB2312 = 1734484000;
  static const int FT_ENCODING_MS_SJIS = 1936353651;
  static const int FT_ENCODING_MS_GB2312 = 1734484000;
  static const int FT_ENCODING_MS_BIG5 = 1651074869;
  static const int FT_ENCODING_MS_WANSUNG = 2002873971;
  static const int FT_ENCODING_MS_JOHAB = 1785686113;
  static const int FT_ENCODING_ADOBE_STANDARD = 1094995778;
  static const int FT_ENCODING_ADOBE_EXPERT = 1094992453;
  static const int FT_ENCODING_ADOBE_CUSTOM = 1094992451;
  static const int FT_ENCODING_ADOBE_LATIN_1 = 1818326065;
  static const int FT_ENCODING_OLD_LATIN_2 = 1818326066;
  static const int FT_ENCODING_APPLE_ROMAN = 1634889070;
}

/// @type:
/// FT_UShort
///
/// @description:
/// A typedef for unsigned short.
typedef FT_UShort = ffi.UnsignedShort;
typedef DartFT_UShort = int;

/// @struct:
/// FT_Generic
///
/// @description:
/// Client applications often need to associate their own data to a
/// variety of FreeType core objects.  For example, a text layout API
/// might want to associate a glyph cache to a given size object.
///
/// Some FreeType object contains a `generic` field, of type `FT_Generic`,
/// which usage is left to client applications and font servers.
///
/// It can be used to store a pointer to client-specific data, as well as
/// the address of a 'finalizer' function, which will be called by
/// FreeType when the object is destroyed (for example, the previous
/// client example would put the address of the glyph cache destructor in
/// the `finalizer` field).
///
/// @fields:
/// data ::
/// A typeless pointer to any client-specified data. This field is
/// completely ignored by the FreeType library.
///
/// finalizer ::
/// A pointer to a 'generic finalizer' function, which will be called
/// when the object is destroyed.  If this field is set to `NULL`, no
/// code will be called.
typedef FT_Generic = FT_Generic_;

/// @struct:
/// FT_Generic
///
/// @description:
/// Client applications often need to associate their own data to a
/// variety of FreeType core objects.  For example, a text layout API
/// might want to associate a glyph cache to a given size object.
///
/// Some FreeType object contains a `generic` field, of type `FT_Generic`,
/// which usage is left to client applications and font servers.
///
/// It can be used to store a pointer to client-specific data, as well as
/// the address of a 'finalizer' function, which will be called by
/// FreeType when the object is destroyed (for example, the previous
/// client example would put the address of the glyph cache destructor in
/// the `finalizer` field).
///
/// @fields:
/// data ::
/// A typeless pointer to any client-specified data. This field is
/// completely ignored by the FreeType library.
///
/// finalizer ::
/// A pointer to a 'generic finalizer' function, which will be called
/// when the object is destroyed.  If this field is set to `NULL`, no
/// code will be called.
final class FT_Generic_ extends ffi.Struct {
  external ffi.Pointer<ffi.Void> data;

  external FT_Generic_Finalizer finalizer;
}

/// @functype:
/// FT_Generic_Finalizer
///
/// @description:
/// Describe a function used to destroy the 'client' data of any FreeType
/// object.  See the description of the @FT_Generic type for details of
/// usage.
///
/// @input:
/// The address of the FreeType object that is under finalization.  Its
/// client data is accessed through its `generic` field.
typedef FT_Generic_Finalizer
    = ffi.Pointer<ffi.NativeFunction<FT_Generic_FinalizerFunction>>;
typedef FT_Generic_FinalizerFunction = ffi.Void Function(
    ffi.Pointer<ffi.Void> object);
typedef DartFT_Generic_FinalizerFunction = void Function(
    ffi.Pointer<ffi.Void> object);

/// @struct:
/// FT_BBox
///
/// @description:
/// A structure used to hold an outline's bounding box, i.e., the
/// coordinates of its extrema in the horizontal and vertical directions.
///
/// @fields:
/// xMin ::
/// The horizontal minimum (left-most).
///
/// yMin ::
/// The vertical minimum (bottom-most).
///
/// xMax ::
/// The horizontal maximum (right-most).
///
/// yMax ::
/// The vertical maximum (top-most).
///
/// @note:
/// The bounding box is specified with the coordinates of the lower left
/// and the upper right corner.  In PostScript, those values are often
/// called (llx,lly) and (urx,ury), respectively.
///
/// If `yMin` is negative, this value gives the glyph's descender.
/// Otherwise, the glyph doesn't descend below the baseline.  Similarly,
/// if `ymax` is positive, this value gives the glyph's ascender.
///
/// `xMin` gives the horizontal distance from the glyph's origin to the
/// left edge of the glyph's bounding box.  If `xMin` is negative, the
/// glyph extends to the left of the origin.
typedef FT_BBox = FT_BBox_;

/// @struct:
/// FT_BBox
///
/// @description:
/// A structure used to hold an outline's bounding box, i.e., the
/// coordinates of its extrema in the horizontal and vertical directions.
///
/// @fields:
/// xMin ::
/// The horizontal minimum (left-most).
///
/// yMin ::
/// The vertical minimum (bottom-most).
///
/// xMax ::
/// The horizontal maximum (right-most).
///
/// yMax ::
/// The vertical maximum (top-most).
///
/// @note:
/// The bounding box is specified with the coordinates of the lower left
/// and the upper right corner.  In PostScript, those values are often
/// called (llx,lly) and (urx,ury), respectively.
///
/// If `yMin` is negative, this value gives the glyph's descender.
/// Otherwise, the glyph doesn't descend below the baseline.  Similarly,
/// if `ymax` is positive, this value gives the glyph's ascender.
///
/// `xMin` gives the horizontal distance from the glyph's origin to the
/// left edge of the glyph's bounding box.  If `xMin` is negative, the
/// glyph extends to the left of the origin.
final class FT_BBox_ extends ffi.Struct {
  @FT_Pos()
  external int xMin;

  @FT_Pos()
  external int yMin;

  @FT_Pos()
  external int xMax;

  @FT_Pos()
  external int yMax;
}

/// @type:
/// FT_GlyphSlot
///
/// @description:
/// A handle to a given 'glyph slot'.  A slot is a container that can hold
/// any of the glyphs contained in its parent face.
///
/// In other words, each time you call @FT_Load_Glyph or @FT_Load_Char,
/// the slot's content is erased by the new glyph data, i.e., the glyph's
/// metrics, its image (bitmap or outline), and other control information.
///
/// @also:
/// See @FT_GlyphSlotRec for the publicly accessible glyph fields.
typedef FT_GlyphSlot = ffi.Pointer<FT_GlyphSlotRec_>;

/// @struct:
/// FT_GlyphSlotRec
///
/// @description:
/// FreeType root glyph slot class structure.  A glyph slot is a container
/// where individual glyphs can be loaded, be they in outline or bitmap
/// format.
///
/// @fields:
/// library ::
/// A handle to the FreeType library instance this slot belongs to.
///
/// face ::
/// A handle to the parent face object.
///
/// next ::
/// In some cases (like some font tools), several glyph slots per face
/// object can be a good thing.  As this is rare, the glyph slots are
/// listed through a direct, single-linked list using its `next` field.
///
/// glyph_index ::
/// [Since 2.10] The glyph index passed as an argument to @FT_Load_Glyph
/// while initializing the glyph slot.
///
/// generic ::
/// A typeless pointer unused by the FreeType library or any of its
/// drivers.  It can be used by client applications to link their own
/// data to each glyph slot object.
///
/// metrics ::
/// The metrics of the last loaded glyph in the slot.  The returned
/// values depend on the last load flags (see the @FT_Load_Glyph API
/// function) and can be expressed either in 26.6 fractional pixels or
/// font units.
///
/// Note that even when the glyph image is transformed, the metrics are
/// not.
///
/// linearHoriAdvance ::
/// The advance width of the unhinted glyph.  Its value is expressed in
/// 16.16 fractional pixels, unless @FT_LOAD_LINEAR_DESIGN is set when
/// loading the glyph.  This field can be important to perform correct
/// WYSIWYG layout.  Only relevant for scalable glyphs.
///
/// linearVertAdvance ::
/// The advance height of the unhinted glyph.  Its value is expressed in
/// 16.16 fractional pixels, unless @FT_LOAD_LINEAR_DESIGN is set when
/// loading the glyph.  This field can be important to perform correct
/// WYSIWYG layout.  Only relevant for scalable glyphs.
///
/// advance ::
/// This shorthand is, depending on @FT_LOAD_IGNORE_TRANSFORM, the
/// transformed (hinted) advance width for the glyph, in 26.6 fractional
/// pixel format.  As specified with @FT_LOAD_VERTICAL_LAYOUT, it uses
/// either the `horiAdvance` or the `vertAdvance` value of `metrics`
/// field.
///
/// format ::
/// This field indicates the format of the image contained in the glyph
/// slot.  Typically @FT_GLYPH_FORMAT_BITMAP, @FT_GLYPH_FORMAT_OUTLINE,
/// or @FT_GLYPH_FORMAT_COMPOSITE, but other values are possible.
///
/// bitmap ::
/// This field is used as a bitmap descriptor.  Note that the address
/// and content of the bitmap buffer can change between calls of
/// @FT_Load_Glyph and a few other functions.
///
/// bitmap_left ::
/// The bitmap's left bearing expressed in integer pixels.
///
/// bitmap_top ::
/// The bitmap's top bearing expressed in integer pixels.  This is the
/// distance from the baseline to the top-most glyph scanline, upwards
/// y~coordinates being **positive**.
///
/// outline ::
/// The outline descriptor for the current glyph image if its format is
/// @FT_GLYPH_FORMAT_OUTLINE.  Once a glyph is loaded, `outline` can be
/// transformed, distorted, emboldened, etc.  However, it must not be
/// freed.
///
/// [Since 2.10.1] If @FT_LOAD_NO_SCALE is set, outline coordinates of
/// OpenType variation fonts for a selected instance are internally
/// handled as 26.6 fractional font units but returned as (rounded)
/// integers, as expected.  To get unrounded font units, don't use
/// @FT_LOAD_NO_SCALE but load the glyph with @FT_LOAD_NO_HINTING and
/// scale it, using the font's `units_per_EM` value as the ppem.
///
/// num_subglyphs ::
/// The number of subglyphs in a composite glyph.  This field is only
/// valid for the composite glyph format that should normally only be
/// loaded with the @FT_LOAD_NO_RECURSE flag.
///
/// subglyphs ::
/// An array of subglyph descriptors for composite glyphs.  There are
/// `num_subglyphs` elements in there.  Currently internal to FreeType.
///
/// control_data ::
/// Certain font drivers can also return the control data for a given
/// glyph image (e.g.  TrueType bytecode, Type~1 charstrings, etc.).
/// This field is a pointer to such data; it is currently internal to
/// FreeType.
///
/// control_len ::
/// This is the length in bytes of the control data.  Currently internal
/// to FreeType.
///
/// other ::
/// Reserved.
///
/// lsb_delta ::
/// The difference between hinted and unhinted left side bearing while
/// auto-hinting is active.  Zero otherwise.
///
/// rsb_delta ::
/// The difference between hinted and unhinted right side bearing while
/// auto-hinting is active.  Zero otherwise.
///
/// @note:
/// If @FT_Load_Glyph is called with default flags (see @FT_LOAD_DEFAULT)
/// the glyph image is loaded in the glyph slot in its native format
/// (e.g., an outline glyph for TrueType and Type~1 formats).  [Since 2.9]
/// The prospective bitmap metrics are calculated according to
/// @FT_LOAD_TARGET_XXX and other flags even for the outline glyph, even
/// if @FT_LOAD_RENDER is not set.
///
/// This image can later be converted into a bitmap by calling
/// @FT_Render_Glyph.  This function searches the current renderer for the
/// native image's format, then invokes it.
///
/// The renderer is in charge of transforming the native image through the
/// slot's face transformation fields, then converting it into a bitmap
/// that is returned in `slot->bitmap`.
///
/// Note that `slot->bitmap_left` and `slot->bitmap_top` are also used to
/// specify the position of the bitmap relative to the current pen
/// position (e.g., coordinates (0,0) on the baseline).  Of course,
/// `slot->format` is also changed to @FT_GLYPH_FORMAT_BITMAP.
///
/// Here is a small pseudo code fragment that shows how to use `lsb_delta`
/// and `rsb_delta` to do fractional positioning of glyphs:
///
/// ```
/// FT_GlyphSlot  slot     = face->glyph;
/// FT_Pos        origin_x = 0;
///
///
/// for all glyphs do
/// <load glyph with `FT_Load_Glyph'>
///
/// FT_Outline_Translate( slot->outline, origin_x & 63, 0 );
///
/// <save glyph image, or render glyph, or ...>
///
/// <compute kern between current and next glyph
/// and add it to `origin_x'>
///
/// origin_x += slot->advance.x;
/// origin_x += slot->lsb_delta - slot->rsb_delta;
/// endfor
/// ```
///
/// Here is another small pseudo code fragment that shows how to use
/// `lsb_delta` and `rsb_delta` to improve integer positioning of glyphs:
///
/// ```
/// FT_GlyphSlot  slot           = face->glyph;
/// FT_Pos        origin_x       = 0;
/// FT_Pos        prev_rsb_delta = 0;
///
///
/// for all glyphs do
/// <compute kern between current and previous glyph
/// and add it to `origin_x'>
///
/// <load glyph with `FT_Load_Glyph'>
///
/// if ( prev_rsb_delta - slot->lsb_delta >  32 )
/// origin_x -= 64;
/// else if ( prev_rsb_delta - slot->lsb_delta < -31 )
/// origin_x += 64;
///
/// prev_rsb_delta = slot->rsb_delta;
///
/// <save glyph image, or render glyph, or ...>
///
/// origin_x += slot->advance.x;
/// endfor
/// ```
///
/// If you use strong auto-hinting, you **must** apply these delta values!
/// Otherwise you will experience far too large inter-glyph spacing at
/// small rendering sizes in most cases.  Note that it doesn't harm to use
/// the above code for other hinting modes also, since the delta values
/// are zero then.
final class FT_GlyphSlotRec_ extends ffi.Struct {
  external FT_Library library1;

  external FT_Face face;

  external FT_GlyphSlot1 next;

  @FT_UInt()
  external int glyph_index;

  external FT_Generic generic;

  external FT_Glyph_Metrics metrics;

  @FT_Fixed()
  external int linearHoriAdvance;

  @FT_Fixed()
  external int linearVertAdvance;

  external FT_Vector advance;

  @ffi.Int32()
  external int format;

  external FT_Bitmap bitmap;

  @FT_Int()
  external int bitmap_left;

  @FT_Int()
  external int bitmap_top;

  external FT_Outline outline;

  @FT_UInt()
  external int num_subglyphs;

  external FT_SubGlyph subglyphs;

  external ffi.Pointer<ffi.Void> control_data;

  @ffi.Long()
  external int control_len;

  @FT_Pos()
  external int lsb_delta;

  @FT_Pos()
  external int rsb_delta;

  external ffi.Pointer<ffi.Void> other;

  external FT_Slot_Internal internal;
}

/// @type:
/// FT_Library
///
/// @description:
/// A handle to a FreeType library instance.  Each 'library' is completely
/// independent from the others; it is the 'root' of a set of objects like
/// fonts, faces, sizes, etc.
///
/// It also embeds a memory manager (see @FT_Memory), as well as a
/// scan-line converter object (see @FT_Raster).
///
/// [Since 2.5.6] In multi-threaded applications it is easiest to use one
/// `FT_Library` object per thread.  In case this is too cumbersome, a
/// single `FT_Library` object across threads is possible also, as long as
/// a mutex lock is used around @FT_New_Face and @FT_Done_Face.
///
/// @note:
/// Library objects are normally created by @FT_Init_FreeType, and
/// destroyed with @FT_Done_FreeType.  If you need reference-counting
/// (cf. @FT_Reference_Library), use @FT_New_Library and @FT_Done_Library.
typedef FT_Library = ffi.Pointer<FT_LibraryRec_>;

/// @type:
/// FT_GlyphSlot
///
/// @description:
/// A handle to a given 'glyph slot'.  A slot is a container that can hold
/// any of the glyphs contained in its parent face.
///
/// In other words, each time you call @FT_Load_Glyph or @FT_Load_Char,
/// the slot's content is erased by the new glyph data, i.e., the glyph's
/// metrics, its image (bitmap or outline), and other control information.
///
/// @also:
/// See @FT_GlyphSlotRec for the publicly accessible glyph fields.
typedef FT_GlyphSlot1 = ffi.Pointer<FT_GlyphSlotRec_>;

/// @type:
/// FT_UInt
///
/// @description:
/// A typedef for the unsigned int type.
typedef FT_UInt = ffi.UnsignedInt;
typedef DartFT_UInt = int;

/// @struct:
/// FT_Glyph_Metrics
///
/// @description:
/// A structure to model the metrics of a single glyph.  The values are
/// expressed in 26.6 fractional pixel format; if the flag
/// @FT_LOAD_NO_SCALE has been used while loading the glyph, values are
/// expressed in font units instead.
///
/// @fields:
/// width ::
/// The glyph's width.
///
/// height ::
/// The glyph's height.
///
/// horiBearingX ::
/// Left side bearing for horizontal layout.
///
/// horiBearingY ::
/// Top side bearing for horizontal layout.
///
/// horiAdvance ::
/// Advance width for horizontal layout.
///
/// vertBearingX ::
/// Left side bearing for vertical layout.
///
/// vertBearingY ::
/// Top side bearing for vertical layout.  Larger positive values mean
/// further below the vertical glyph origin.
///
/// vertAdvance ::
/// Advance height for vertical layout.  Positive values mean the glyph
/// has a positive advance downward.
///
/// @note:
/// If not disabled with @FT_LOAD_NO_HINTING, the values represent
/// dimensions of the hinted glyph (in case hinting is applicable).
///
/// Stroking a glyph with an outside border does not increase
/// `horiAdvance` or `vertAdvance`; you have to manually adjust these
/// values to account for the added width and height.
///
/// FreeType doesn't use the 'VORG' table data for CFF fonts because it
/// doesn't have an interface to quickly retrieve the glyph height.  The
/// y~coordinate of the vertical origin can be simply computed as
/// `vertBearingY + height` after loading a glyph.
typedef FT_Glyph_Metrics = FT_Glyph_Metrics_;

/// @type:
/// FT_Fixed
///
/// @description:
/// This type is used to store 16.16 fixed-point values, like scaling
/// values or matrix coefficients.
typedef FT_Fixed = ffi.Long;
typedef DartFT_Fixed = int;

/// @struct:
/// FT_Vector
///
/// @description:
/// A simple structure used to store a 2D vector; coordinates are of the
/// FT_Pos type.
///
/// @fields:
/// x ::
/// The horizontal coordinate.
/// y ::
/// The vertical coordinate.
typedef FT_Vector = FT_Vector_;

/// @struct:
/// FT_Vector
///
/// @description:
/// A simple structure used to store a 2D vector; coordinates are of the
/// FT_Pos type.
///
/// @fields:
/// x ::
/// The horizontal coordinate.
/// y ::
/// The vertical coordinate.
final class FT_Vector_ extends ffi.Struct {
  @FT_Pos()
  external int x;

  @FT_Pos()
  external int y;
}

/// @enum:
/// FT_Glyph_Format
///
/// @description:
/// An enumeration type used to describe the format of a given glyph
/// image.  Note that this version of FreeType only supports two image
/// formats, even though future font drivers will be able to register
/// their own format.
///
/// @values:
/// FT_GLYPH_FORMAT_NONE ::
/// The value~0 is reserved.
///
/// FT_GLYPH_FORMAT_COMPOSITE ::
/// The glyph image is a composite of several other images.  This format
/// is _only_ used with @FT_LOAD_NO_RECURSE, and is used to report
/// compound glyphs (like accented characters).
///
/// FT_GLYPH_FORMAT_BITMAP ::
/// The glyph image is a bitmap, and can be described as an @FT_Bitmap.
/// You generally need to access the `bitmap` field of the
/// @FT_GlyphSlotRec structure to read it.
///
/// FT_GLYPH_FORMAT_OUTLINE ::
/// The glyph image is a vectorial outline made of line segments and
/// Bezier arcs; it can be described as an @FT_Outline; you generally
/// want to access the `outline` field of the @FT_GlyphSlotRec structure
/// to read it.
///
/// FT_GLYPH_FORMAT_PLOTTER ::
/// The glyph image is a vectorial path with no inside and outside
/// contours.  Some Type~1 fonts, like those in the Hershey family,
/// contain glyphs in this format.  These are described as @FT_Outline,
/// but FreeType isn't currently capable of rendering them correctly.
///
/// FT_GLYPH_FORMAT_SVG ::
/// [Since 2.12] The glyph is represented by an SVG document in the
/// 'SVG~' table.
abstract class FT_Glyph_Format_ {
  static const int FT_GLYPH_FORMAT_NONE = 0;
  static const int FT_GLYPH_FORMAT_COMPOSITE = 1668246896;
  static const int FT_GLYPH_FORMAT_BITMAP = 1651078259;
  static const int FT_GLYPH_FORMAT_OUTLINE = 1869968492;
  static const int FT_GLYPH_FORMAT_PLOTTER = 1886154612;
  static const int FT_GLYPH_FORMAT_SVG = 1398163232;
}

/// @struct:
/// FT_Bitmap
///
/// @description:
/// A structure used to describe a bitmap or pixmap to the raster.  Note
/// that we now manage pixmaps of various depths through the `pixel_mode`
/// field.
///
/// @fields:
/// rows ::
/// The number of bitmap rows.
///
/// width ::
/// The number of pixels in bitmap row.
///
/// pitch ::
/// The pitch's absolute value is the number of bytes taken by one
/// bitmap row, including padding.  However, the pitch is positive when
/// the bitmap has a 'down' flow, and negative when it has an 'up' flow.
/// In all cases, the pitch is an offset to add to a bitmap pointer in
/// order to go down one row.
///
/// Note that 'padding' means the alignment of a bitmap to a byte
/// border, and FreeType functions normally align to the smallest
/// possible integer value.
///
/// For the B/W rasterizer, `pitch` is always an even number.
///
/// To change the pitch of a bitmap (say, to make it a multiple of 4),
/// use @FT_Bitmap_Convert.  Alternatively, you might use callback
/// functions to directly render to the application's surface; see the
/// file `example2.cpp` in the tutorial for a demonstration.
///
/// buffer ::
/// A typeless pointer to the bitmap buffer.  This value should be
/// aligned on 32-bit boundaries in most cases.
///
/// num_grays ::
/// This field is only used with @FT_PIXEL_MODE_GRAY; it gives the
/// number of gray levels used in the bitmap.
///
/// pixel_mode ::
/// The pixel mode, i.e., how pixel bits are stored.  See @FT_Pixel_Mode
/// for possible values.
///
/// palette_mode ::
/// This field is intended for paletted pixel modes; it indicates how
/// the palette is stored.  Not used currently.
///
/// palette ::
/// A typeless pointer to the bitmap palette; this field is intended for
/// paletted pixel modes.  Not used currently.
///
/// @note:
/// `width` and `rows` refer to the *physical* size of the bitmap, not the
/// *logical* one.  For example, if @FT_Pixel_Mode is set to
/// `FT_PIXEL_MODE_LCD`, the logical width is a just a third of the
/// physical one.
typedef FT_Bitmap = FT_Bitmap_;

/// @struct:
/// FT_Bitmap
///
/// @description:
/// A structure used to describe a bitmap or pixmap to the raster.  Note
/// that we now manage pixmaps of various depths through the `pixel_mode`
/// field.
///
/// @fields:
/// rows ::
/// The number of bitmap rows.
///
/// width ::
/// The number of pixels in bitmap row.
///
/// pitch ::
/// The pitch's absolute value is the number of bytes taken by one
/// bitmap row, including padding.  However, the pitch is positive when
/// the bitmap has a 'down' flow, and negative when it has an 'up' flow.
/// In all cases, the pitch is an offset to add to a bitmap pointer in
/// order to go down one row.
///
/// Note that 'padding' means the alignment of a bitmap to a byte
/// border, and FreeType functions normally align to the smallest
/// possible integer value.
///
/// For the B/W rasterizer, `pitch` is always an even number.
///
/// To change the pitch of a bitmap (say, to make it a multiple of 4),
/// use @FT_Bitmap_Convert.  Alternatively, you might use callback
/// functions to directly render to the application's surface; see the
/// file `example2.cpp` in the tutorial for a demonstration.
///
/// buffer ::
/// A typeless pointer to the bitmap buffer.  This value should be
/// aligned on 32-bit boundaries in most cases.
///
/// num_grays ::
/// This field is only used with @FT_PIXEL_MODE_GRAY; it gives the
/// number of gray levels used in the bitmap.
///
/// pixel_mode ::
/// The pixel mode, i.e., how pixel bits are stored.  See @FT_Pixel_Mode
/// for possible values.
///
/// palette_mode ::
/// This field is intended for paletted pixel modes; it indicates how
/// the palette is stored.  Not used currently.
///
/// palette ::
/// A typeless pointer to the bitmap palette; this field is intended for
/// paletted pixel modes.  Not used currently.
///
/// @note:
/// `width` and `rows` refer to the *physical* size of the bitmap, not the
/// *logical* one.  For example, if @FT_Pixel_Mode is set to
/// `FT_PIXEL_MODE_LCD`, the logical width is a just a third of the
/// physical one.
final class FT_Bitmap_ extends ffi.Struct {
  @ffi.UnsignedInt()
  external int rows;

  @ffi.UnsignedInt()
  external int width;

  @ffi.Int()
  external int pitch;

  external ffi.Pointer<ffi.UnsignedChar> buffer;

  @ffi.UnsignedShort()
  external int num_grays;

  @ffi.UnsignedChar()
  external int pixel_mode;

  @ffi.UnsignedChar()
  external int palette_mode;

  external ffi.Pointer<ffi.Void> palette;
}

/// @struct:
/// FT_Outline
///
/// @description:
/// This structure is used to describe an outline to the scan-line
/// converter.
///
/// @fields:
/// n_contours ::
/// The number of contours in the outline.
///
/// n_points ::
/// The number of points in the outline.
///
/// points ::
/// A pointer to an array of `n_points` @FT_Vector elements, giving the
/// outline's point coordinates.
///
/// tags ::
/// A pointer to an array of `n_points` chars, giving each outline
/// point's type.
///
/// If bit~0 is unset, the point is 'off' the curve, i.e., a Bezier
/// control point, while it is 'on' if set.
///
/// Bit~1 is meaningful for 'off' points only.  If set, it indicates a
/// third-order Bezier arc control point; and a second-order control
/// point if unset.
///
/// If bit~2 is set, bits 5-7 contain the drop-out mode (as defined in
/// the OpenType specification; the value is the same as the argument to
/// the 'SCANMODE' instruction).
///
/// Bits 3 and~4 are reserved for internal purposes.
///
/// contours ::
/// An array of `n_contours` shorts, giving the end point of each
/// contour within the outline.  For example, the first contour is
/// defined by the points '0' to `contours[0]`, the second one is
/// defined by the points `contours[0]+1` to `contours[1]`, etc.
///
/// flags ::
/// A set of bit flags used to characterize the outline and give hints
/// to the scan-converter and hinter on how to convert/grid-fit it.  See
/// @FT_OUTLINE_XXX.
///
/// @note:
/// The B/W rasterizer only checks bit~2 in the `tags` array for the first
/// point of each contour.  The drop-out mode as given with
/// @FT_OUTLINE_IGNORE_DROPOUTS, @FT_OUTLINE_SMART_DROPOUTS, and
/// @FT_OUTLINE_INCLUDE_STUBS in `flags` is then overridden.
typedef FT_Outline = FT_Outline_;

/// @struct:
/// FT_Outline
///
/// @description:
/// This structure is used to describe an outline to the scan-line
/// converter.
///
/// @fields:
/// n_contours ::
/// The number of contours in the outline.
///
/// n_points ::
/// The number of points in the outline.
///
/// points ::
/// A pointer to an array of `n_points` @FT_Vector elements, giving the
/// outline's point coordinates.
///
/// tags ::
/// A pointer to an array of `n_points` chars, giving each outline
/// point's type.
///
/// If bit~0 is unset, the point is 'off' the curve, i.e., a Bezier
/// control point, while it is 'on' if set.
///
/// Bit~1 is meaningful for 'off' points only.  If set, it indicates a
/// third-order Bezier arc control point; and a second-order control
/// point if unset.
///
/// If bit~2 is set, bits 5-7 contain the drop-out mode (as defined in
/// the OpenType specification; the value is the same as the argument to
/// the 'SCANMODE' instruction).
///
/// Bits 3 and~4 are reserved for internal purposes.
///
/// contours ::
/// An array of `n_contours` shorts, giving the end point of each
/// contour within the outline.  For example, the first contour is
/// defined by the points '0' to `contours[0]`, the second one is
/// defined by the points `contours[0]+1` to `contours[1]`, etc.
///
/// flags ::
/// A set of bit flags used to characterize the outline and give hints
/// to the scan-converter and hinter on how to convert/grid-fit it.  See
/// @FT_OUTLINE_XXX.
///
/// @note:
/// The B/W rasterizer only checks bit~2 in the `tags` array for the first
/// point of each contour.  The drop-out mode as given with
/// @FT_OUTLINE_IGNORE_DROPOUTS, @FT_OUTLINE_SMART_DROPOUTS, and
/// @FT_OUTLINE_INCLUDE_STUBS in `flags` is then overridden.
final class FT_Outline_ extends ffi.Struct {
  @ffi.Short()
  external int n_contours;

  @ffi.Short()
  external int n_points;

  external ffi.Pointer<FT_Vector> points;

  external ffi.Pointer<ffi.Char> tags;

  external ffi.Pointer<ffi.Short> contours;

  @ffi.Int()
  external int flags;
}

/// @struct:
/// FT_SubGlyph
///
/// @description:
/// The subglyph structure is an internal object used to describe
/// subglyphs (for example, in the case of composites).
///
/// @note:
/// The subglyph implementation is not part of the high-level API, hence
/// the forward structure declaration.
///
/// You can however retrieve subglyph information with
/// @FT_Get_SubGlyph_Info.
typedef FT_SubGlyph = ffi.Pointer<FT_SubGlyphRec_>;

final class FT_SubGlyphRec_ extends ffi.Opaque {}

/// @type:
/// FT_Slot_Internal
///
/// @description:
/// An opaque handle to an `FT_Slot_InternalRec` structure, used to model
/// private data of a given @FT_GlyphSlot object.
typedef FT_Slot_Internal = ffi.Pointer<FT_Slot_InternalRec_>;

final class FT_Slot_InternalRec_ extends ffi.Opaque {}

/// @type:
/// FT_Size
///
/// @description:
/// A handle to an object that models a face scaled to a given character
/// size.
///
/// @note:
/// An @FT_Face has one _active_ `FT_Size` object that is used by
/// functions like @FT_Load_Glyph to determine the scaling transformation
/// that in turn is used to load and hint glyphs and metrics.
///
/// A newly created `FT_Size` object contains only meaningless zero values.
/// You must use @FT_Set_Char_Size, @FT_Set_Pixel_Sizes, @FT_Request_Size
/// or even @FT_Select_Size to change the content (i.e., the scaling
/// values) of the active `FT_Size`.  Otherwise, the scaling and hinting
/// will not be performed.
///
/// You can use @FT_New_Size to create additional size objects for a given
/// @FT_Face, but they won't be used by other functions until you activate
/// it through @FT_Activate_Size.  Only one size can be activated at any
/// given time per face.
///
/// @also:
/// See @FT_SizeRec for the publicly accessible fields of a given size
/// object.
typedef FT_Size = ffi.Pointer<FT_SizeRec_>;

/// @struct:
/// FT_SizeRec
///
/// @description:
/// FreeType root size class structure.  A size object models a face
/// object at a given size.
///
/// @fields:
/// face ::
/// Handle to the parent face object.
///
/// generic ::
/// A typeless pointer, unused by the FreeType library or any of its
/// drivers.  It can be used by client applications to link their own
/// data to each size object.
///
/// metrics ::
/// Metrics for this size object.  This field is read-only.
final class FT_SizeRec_ extends ffi.Struct {
  external FT_Face face;

  external FT_Generic generic;

  external FT_Size_Metrics metrics;

  external FT_Size_Internal internal;
}

/// @struct:
/// FT_Size_Metrics
///
/// @description:
/// The size metrics structure gives the metrics of a size object.
///
/// @fields:
/// x_ppem ::
/// The width of the scaled EM square in pixels, hence the term 'ppem'
/// (pixels per EM).  It is also referred to as 'nominal width'.
///
/// y_ppem ::
/// The height of the scaled EM square in pixels, hence the term 'ppem'
/// (pixels per EM).  It is also referred to as 'nominal height'.
///
/// x_scale ::
/// A 16.16 fractional scaling value to convert horizontal metrics from
/// font units to 26.6 fractional pixels.  Only relevant for scalable
/// font formats.
///
/// y_scale ::
/// A 16.16 fractional scaling value to convert vertical metrics from
/// font units to 26.6 fractional pixels.  Only relevant for scalable
/// font formats.
///
/// ascender ::
/// The ascender in 26.6 fractional pixels, rounded up to an integer
/// value.  See @FT_FaceRec for the details.
///
/// descender ::
/// The descender in 26.6 fractional pixels, rounded down to an integer
/// value.  See @FT_FaceRec for the details.
///
/// height ::
/// The height in 26.6 fractional pixels, rounded to an integer value.
/// See @FT_FaceRec for the details.
///
/// max_advance ::
/// The maximum advance width in 26.6 fractional pixels, rounded to an
/// integer value.  See @FT_FaceRec for the details.
///
/// @note:
/// The scaling values, if relevant, are determined first during a size
/// changing operation.  The remaining fields are then set by the driver.
/// For scalable formats, they are usually set to scaled values of the
/// corresponding fields in @FT_FaceRec.  Some values like ascender or
/// descender are rounded for historical reasons; more precise values (for
/// outline fonts) can be derived by scaling the corresponding @FT_FaceRec
/// values manually, with code similar to the following.
///
/// ```
/// scaled_ascender = FT_MulFix( face->ascender,
/// size_metrics->y_scale );
/// ```
///
/// Note that due to glyph hinting and the selected rendering mode these
/// values are usually not exact; consequently, they must be treated as
/// unreliable with an error margin of at least one pixel!
///
/// Indeed, the only way to get the exact metrics is to render _all_
/// glyphs.  As this would be a definite performance hit, it is up to
/// client applications to perform such computations.
///
/// The `FT_Size_Metrics` structure is valid for bitmap fonts also.
///
///
/// **TrueType fonts with native bytecode hinting**
///
/// All applications that handle TrueType fonts with native hinting must
/// be aware that TTFs expect different rounding of vertical font
/// dimensions.  The application has to cater for this, especially if it
/// wants to rely on a TTF's vertical data (for example, to properly align
/// box characters vertically).
///
/// Only the application knows _in advance_ that it is going to use native
/// hinting for TTFs!  FreeType, on the other hand, selects the hinting
/// mode not at the time of creating an @FT_Size object but much later,
/// namely while calling @FT_Load_Glyph.
///
/// Here is some pseudo code that illustrates a possible solution.
///
/// ```
/// font_format = FT_Get_Font_Format( face );
///
/// if ( !strcmp( font_format, "TrueType" ) &&
/// do_native_bytecode_hinting         )
/// {
/// ascender  = ROUND( FT_MulFix( face->ascender,
/// size_metrics->y_scale ) );
/// descender = ROUND( FT_MulFix( face->descender,
/// size_metrics->y_scale ) );
/// }
/// else
/// {
/// ascender  = size_metrics->ascender;
/// descender = size_metrics->descender;
/// }
///
/// height      = size_metrics->height;
/// max_advance = size_metrics->max_advance;
/// ```
typedef FT_Size_Metrics = FT_Size_Metrics_;

/// @struct:
/// FT_Size_Metrics
///
/// @description:
/// The size metrics structure gives the metrics of a size object.
///
/// @fields:
/// x_ppem ::
/// The width of the scaled EM square in pixels, hence the term 'ppem'
/// (pixels per EM).  It is also referred to as 'nominal width'.
///
/// y_ppem ::
/// The height of the scaled EM square in pixels, hence the term 'ppem'
/// (pixels per EM).  It is also referred to as 'nominal height'.
///
/// x_scale ::
/// A 16.16 fractional scaling value to convert horizontal metrics from
/// font units to 26.6 fractional pixels.  Only relevant for scalable
/// font formats.
///
/// y_scale ::
/// A 16.16 fractional scaling value to convert vertical metrics from
/// font units to 26.6 fractional pixels.  Only relevant for scalable
/// font formats.
///
/// ascender ::
/// The ascender in 26.6 fractional pixels, rounded up to an integer
/// value.  See @FT_FaceRec for the details.
///
/// descender ::
/// The descender in 26.6 fractional pixels, rounded down to an integer
/// value.  See @FT_FaceRec for the details.
///
/// height ::
/// The height in 26.6 fractional pixels, rounded to an integer value.
/// See @FT_FaceRec for the details.
///
/// max_advance ::
/// The maximum advance width in 26.6 fractional pixels, rounded to an
/// integer value.  See @FT_FaceRec for the details.
///
/// @note:
/// The scaling values, if relevant, are determined first during a size
/// changing operation.  The remaining fields are then set by the driver.
/// For scalable formats, they are usually set to scaled values of the
/// corresponding fields in @FT_FaceRec.  Some values like ascender or
/// descender are rounded for historical reasons; more precise values (for
/// outline fonts) can be derived by scaling the corresponding @FT_FaceRec
/// values manually, with code similar to the following.
///
/// ```
/// scaled_ascender = FT_MulFix( face->ascender,
/// size_metrics->y_scale );
/// ```
///
/// Note that due to glyph hinting and the selected rendering mode these
/// values are usually not exact; consequently, they must be treated as
/// unreliable with an error margin of at least one pixel!
///
/// Indeed, the only way to get the exact metrics is to render _all_
/// glyphs.  As this would be a definite performance hit, it is up to
/// client applications to perform such computations.
///
/// The `FT_Size_Metrics` structure is valid for bitmap fonts also.
///
///
/// **TrueType fonts with native bytecode hinting**
///
/// All applications that handle TrueType fonts with native hinting must
/// be aware that TTFs expect different rounding of vertical font
/// dimensions.  The application has to cater for this, especially if it
/// wants to rely on a TTF's vertical data (for example, to properly align
/// box characters vertically).
///
/// Only the application knows _in advance_ that it is going to use native
/// hinting for TTFs!  FreeType, on the other hand, selects the hinting
/// mode not at the time of creating an @FT_Size object but much later,
/// namely while calling @FT_Load_Glyph.
///
/// Here is some pseudo code that illustrates a possible solution.
///
/// ```
/// font_format = FT_Get_Font_Format( face );
///
/// if ( !strcmp( font_format, "TrueType" ) &&
/// do_native_bytecode_hinting         )
/// {
/// ascender  = ROUND( FT_MulFix( face->ascender,
/// size_metrics->y_scale ) );
/// descender = ROUND( FT_MulFix( face->descender,
/// size_metrics->y_scale ) );
/// }
/// else
/// {
/// ascender  = size_metrics->ascender;
/// descender = size_metrics->descender;
/// }
///
/// height      = size_metrics->height;
/// max_advance = size_metrics->max_advance;
/// ```
final class FT_Size_Metrics_ extends ffi.Struct {
  @FT_UShort()
  external int x_ppem;

  @FT_UShort()
  external int y_ppem;

  @FT_Fixed()
  external int x_scale;

  @FT_Fixed()
  external int y_scale;

  @FT_Pos()
  external int ascender;

  @FT_Pos()
  external int descender;

  @FT_Pos()
  external int height;

  @FT_Pos()
  external int max_advance;
}

/// @type:
/// FT_Size_Internal
///
/// @description:
/// An opaque handle to an `FT_Size_InternalRec` structure, used to model
/// private data of a given @FT_Size object.
typedef FT_Size_Internal = ffi.Pointer<FT_Size_InternalRec_>;

final class FT_Size_InternalRec_ extends ffi.Opaque {}

/// @type:
/// FT_Driver
///
/// @description:
/// A handle to a given FreeType font driver object.  A font driver is a
/// module capable of creating faces from font files.
typedef FT_Driver = ffi.Pointer<FT_DriverRec_>;

/// @type:
/// FT_Memory
///
/// @description:
/// A handle to a given memory manager object, defined with an
/// @FT_MemoryRec structure.
typedef FT_Memory = ffi.Pointer<FT_MemoryRec_>;

/// @struct:
/// FT_MemoryRec
///
/// @description:
/// A structure used to describe a given memory manager to FreeType~2.
///
/// @fields:
/// user ::
/// A generic typeless pointer for user data.
///
/// alloc ::
/// A pointer type to an allocation function.
///
/// free ::
/// A pointer type to an memory freeing function.
///
/// realloc ::
/// A pointer type to a reallocation function.
final class FT_MemoryRec_ extends ffi.Struct {
  external ffi.Pointer<ffi.Void> user;

  external FT_Alloc_Func alloc;

  external FT_Free_Func free;

  external FT_Realloc_Func realloc;
}

/// @functype:
/// FT_Alloc_Func
///
/// @description:
/// A function used to allocate `size` bytes from `memory`.
///
/// @input:
/// memory ::
/// A handle to the source memory manager.
///
/// size ::
/// The size in bytes to allocate.
///
/// @return:
/// Address of new memory block.  0~in case of failure.
typedef FT_Alloc_Func = ffi.Pointer<ffi.NativeFunction<FT_Alloc_FuncFunction>>;
typedef FT_Alloc_FuncFunction = ffi.Pointer<ffi.Void> Function(
    FT_Memory1 memory, ffi.Long size);
typedef DartFT_Alloc_FuncFunction = ffi.Pointer<ffi.Void> Function(
    FT_Memory1 memory, int size);

/// @type:
/// FT_Memory
///
/// @description:
/// A handle to a given memory manager object, defined with an
/// @FT_MemoryRec structure.
typedef FT_Memory1 = ffi.Pointer<FT_MemoryRec_>;

/// @functype:
/// FT_Free_Func
///
/// @description:
/// A function used to release a given block of memory.
///
/// @input:
/// memory ::
/// A handle to the source memory manager.
///
/// block ::
/// The address of the target memory block.
typedef FT_Free_Func = ffi.Pointer<ffi.NativeFunction<FT_Free_FuncFunction>>;
typedef FT_Free_FuncFunction = ffi.Void Function(
    FT_Memory1 memory, ffi.Pointer<ffi.Void> block);
typedef DartFT_Free_FuncFunction = void Function(
    FT_Memory1 memory, ffi.Pointer<ffi.Void> block);

/// @functype:
/// FT_Realloc_Func
///
/// @description:
/// A function used to re-allocate a given block of memory.
///
/// @input:
/// memory ::
/// A handle to the source memory manager.
///
/// cur_size ::
/// The block's current size in bytes.
///
/// new_size ::
/// The block's requested new size.
///
/// block ::
/// The block's current address.
///
/// @return:
/// New block address.  0~in case of memory shortage.
///
/// @note:
/// In case of error, the old block must still be available.
typedef FT_Realloc_Func
    = ffi.Pointer<ffi.NativeFunction<FT_Realloc_FuncFunction>>;
typedef FT_Realloc_FuncFunction = ffi.Pointer<ffi.Void> Function(
    FT_Memory1 memory,
    ffi.Long cur_size,
    ffi.Long new_size,
    ffi.Pointer<ffi.Void> block);
typedef DartFT_Realloc_FuncFunction = ffi.Pointer<ffi.Void> Function(
    FT_Memory1 memory, int cur_size, int new_size, ffi.Pointer<ffi.Void> block);

/// @type:
/// FT_Stream
///
/// @description:
/// A handle to an input stream.
///
/// @also:
/// See @FT_StreamRec for the publicly accessible fields of a given stream
/// object.
typedef FT_Stream = ffi.Pointer<FT_StreamRec_>;

/// @struct:
/// FT_StreamRec
///
/// @description:
/// A structure used to describe an input stream.
///
/// @input:
/// base ::
/// For memory-based streams, this is the address of the first stream
/// byte in memory.  This field should always be set to `NULL` for
/// disk-based streams.
///
/// size ::
/// The stream size in bytes.
///
/// In case of compressed streams where the size is unknown before
/// actually doing the decompression, the value is set to 0x7FFFFFFF.
/// (Note that this size value can occur for normal streams also; it is
/// thus just a hint.)
///
/// pos ::
/// The current position within the stream.
///
/// descriptor ::
/// This field is a union that can hold an integer or a pointer.  It is
/// used by stream implementations to store file descriptors or `FILE*`
/// pointers.
///
/// pathname ::
/// This field is completely ignored by FreeType.  However, it is often
/// useful during debugging to use it to store the stream's filename
/// (where available).
///
/// read ::
/// The stream's input function.
///
/// close ::
/// The stream's close function.
///
/// memory ::
/// The memory manager to use to preload frames.  This is set internally
/// by FreeType and shouldn't be touched by stream implementations.
///
/// cursor ::
/// This field is set and used internally by FreeType when parsing
/// frames.  In particular, the `FT_GET_XXX` macros use this instead of
/// the `pos` field.
///
/// limit ::
/// This field is set and used internally by FreeType when parsing
/// frames.
final class FT_StreamRec_ extends ffi.Struct {
  external ffi.Pointer<ffi.UnsignedChar> base;

  @ffi.UnsignedLong()
  external int size;

  @ffi.UnsignedLong()
  external int pos;

  external FT_StreamDesc descriptor;

  external FT_StreamDesc pathname;

  external FT_Stream_IoFunc read;

  external FT_Stream_CloseFunc close;

  external FT_Memory memory;

  external ffi.Pointer<ffi.UnsignedChar> cursor;

  external ffi.Pointer<ffi.UnsignedChar> limit;
}

/// @struct:
/// FT_StreamDesc
///
/// @description:
/// A union type used to store either a long or a pointer.  This is used
/// to store a file descriptor or a `FILE*` in an input stream.
typedef FT_StreamDesc = FT_StreamDesc_;

/// @struct:
/// FT_StreamDesc
///
/// @description:
/// A union type used to store either a long or a pointer.  This is used
/// to store a file descriptor or a `FILE*` in an input stream.
final class FT_StreamDesc_ extends ffi.Union {
  @ffi.Long()
  external int value;

  external ffi.Pointer<ffi.Void> pointer;
}

/// @functype:
/// FT_Stream_IoFunc
///
/// @description:
/// A function used to seek and read data from a given input stream.
///
/// @input:
/// stream ::
/// A handle to the source stream.
///
/// offset ::
/// The offset from the start of the stream to seek to.
///
/// buffer ::
/// The address of the read buffer.
///
/// count ::
/// The number of bytes to read from the stream.
///
/// @return:
/// If count >~0, return the number of bytes effectively read by the
/// stream (after seeking to `offset`).  If count ==~0, return the status
/// of the seek operation (non-zero indicates an error).
typedef FT_Stream_IoFunc
    = ffi.Pointer<ffi.NativeFunction<FT_Stream_IoFuncFunction>>;
typedef FT_Stream_IoFuncFunction = ffi.UnsignedLong Function(
    FT_Stream1 stream,
    ffi.UnsignedLong offset,
    ffi.Pointer<ffi.UnsignedChar> buffer,
    ffi.UnsignedLong count);
typedef DartFT_Stream_IoFuncFunction = int Function(FT_Stream1 stream,
    int offset, ffi.Pointer<ffi.UnsignedChar> buffer, int count);

/// @type:
/// FT_Stream
///
/// @description:
/// A handle to an input stream.
///
/// @also:
/// See @FT_StreamRec for the publicly accessible fields of a given stream
/// object.
typedef FT_Stream1 = ffi.Pointer<FT_StreamRec_>;

/// @functype:
/// FT_Stream_CloseFunc
///
/// @description:
/// A function used to close a given input stream.
///
/// @input:
/// stream ::
/// A handle to the target stream.
typedef FT_Stream_CloseFunc
    = ffi.Pointer<ffi.NativeFunction<FT_Stream_CloseFuncFunction>>;
typedef FT_Stream_CloseFuncFunction = ffi.Void Function(FT_Stream1 stream);
typedef DartFT_Stream_CloseFuncFunction = void Function(FT_Stream1 stream);

/// @struct:
/// FT_ListRec
///
/// @description:
/// A structure used to hold a simple doubly-linked list.  These are used
/// in many parts of FreeType.
///
/// @fields:
/// head ::
/// The head (first element) of doubly-linked list.
///
/// tail ::
/// The tail (last element) of doubly-linked list.
typedef FT_ListRec = FT_ListRec_;

/// @struct:
/// FT_ListRec
///
/// @description:
/// A structure used to hold a simple doubly-linked list.  These are used
/// in many parts of FreeType.
///
/// @fields:
/// head ::
/// The head (first element) of doubly-linked list.
///
/// tail ::
/// The tail (last element) of doubly-linked list.
final class FT_ListRec_ extends ffi.Struct {
  external FT_ListNode head;

  external FT_ListNode tail;
}

/// @type:
/// FT_ListNode
///
/// @description:
/// Many elements and objects in FreeType are listed through an @FT_List
/// record (see @FT_ListRec).  As its name suggests, an FT_ListNode is a
/// handle to a single list element.
typedef FT_ListNode = ffi.Pointer<FT_ListNodeRec_>;

/// @struct:
/// FT_ListNodeRec
///
/// @description:
/// A structure used to hold a single list element.
///
/// @fields:
/// prev ::
/// The previous element in the list.  `NULL` if first.
///
/// next ::
/// The next element in the list.  `NULL` if last.
///
/// data ::
/// A typeless pointer to the listed object.
final class FT_ListNodeRec_ extends ffi.Struct {
  external FT_ListNode1 prev;

  external FT_ListNode1 next;

  external ffi.Pointer<ffi.Void> data;
}

/// @type:
/// FT_ListNode
///
/// @description:
/// Many elements and objects in FreeType are listed through an @FT_List
/// record (see @FT_ListRec).  As its name suggests, an FT_ListNode is a
/// handle to a single list element.
typedef FT_ListNode1 = ffi.Pointer<FT_ListNodeRec_>;

/// @type:
/// FT_Face_Internal
///
/// @description:
/// An opaque handle to an `FT_Face_InternalRec` structure that models the
/// private data of a given @FT_Face object.
///
/// This structure might change between releases of FreeType~2 and is not
/// generally available to client applications.
typedef FT_Face_Internal = ffi.Pointer<FT_Face_InternalRec_>;

final class FT_Face_InternalRec_ extends ffi.Opaque {}

/// @type:
/// FT_Error
///
/// @description:
/// The FreeType error code type.  A value of~0 is always interpreted as a
/// successful operation.
typedef FT_Error = ffi.Int;
typedef DartFT_Error = int;

/// @struct:
/// FT_Parameter
///
/// @description:
/// A simple structure to pass more or less generic parameters to
/// @FT_Open_Face and @FT_Face_Properties.
///
/// @fields:
/// tag ::
/// A four-byte identification tag.
///
/// data ::
/// A pointer to the parameter data.
///
/// @note:
/// The ID and function of parameters are driver-specific.  See section
/// @parameter_tags for more information.
final class FT_Parameter_ extends ffi.Struct {
  @FT_ULong()
  external int tag;

  external FT_Pointer data;
}

/// @type:
/// FT_ULong
///
/// @description:
/// A typedef for unsigned long.
typedef FT_ULong = ffi.UnsignedLong;
typedef DartFT_ULong = int;

/// @type:
/// FT_Pointer
///
/// @description:
/// A simple typedef for a typeless pointer.
typedef FT_Pointer = ffi.Pointer<ffi.Void>;

/// @struct:
/// FT_Open_Args
///
/// @description:
/// A structure to indicate how to open a new font file or stream.  A
/// pointer to such a structure can be used as a parameter for the
/// functions @FT_Open_Face and @FT_Attach_Stream.
///
/// @fields:
/// flags ::
/// A set of bit flags indicating how to use the structure.
///
/// memory_base ::
/// The first byte of the file in memory.
///
/// memory_size ::
/// The size in bytes of the file in memory.
///
/// pathname ::
/// A pointer to an 8-bit file pathname, which must be a C~string (i.e.,
/// no null bytes except at the very end).  The pointer is not owned by
/// FreeType.
///
/// stream ::
/// A handle to a source stream object.
///
/// driver ::
/// This field is exclusively used by @FT_Open_Face; it simply specifies
/// the font driver to use for opening the face.  If set to `NULL`,
/// FreeType tries to load the face with each one of the drivers in its
/// list.
///
/// num_params ::
/// The number of extra parameters.
///
/// params ::
/// Extra parameters passed to the font driver when opening a new face.
///
/// @note:
/// The stream type is determined by the contents of `flags`:
///
/// If the @FT_OPEN_MEMORY bit is set, assume that this is a memory file
/// of `memory_size` bytes, located at `memory_address`.  The data are not
/// copied, and the client is responsible for releasing and destroying
/// them _after_ the corresponding call to @FT_Done_Face.
///
/// Otherwise, if the @FT_OPEN_STREAM bit is set, assume that a custom
/// input stream `stream` is used.
///
/// Otherwise, if the @FT_OPEN_PATHNAME bit is set, assume that this is a
/// normal file and use `pathname` to open it.
///
/// If none of the above bits are set or if multiple are set at the same
/// time, the flags are invalid and @FT_Open_Face fails.
///
/// If the @FT_OPEN_DRIVER bit is set, @FT_Open_Face only tries to open
/// the file with the driver whose handler is in `driver`.
///
/// If the @FT_OPEN_PARAMS bit is set, the parameters given by
/// `num_params` and `params` is used.  They are ignored otherwise.
///
/// Ideally, both the `pathname` and `params` fields should be tagged as
/// 'const'; this is missing for API backward compatibility.  In other
/// words, applications should treat them as read-only.
final class FT_Open_Args_ extends ffi.Struct {
  @FT_UInt()
  external int flags;

  external ffi.Pointer<FT_Byte> memory_base;

  @FT_Long()
  external int memory_size;

  external ffi.Pointer<FT_String> pathname;

  external FT_Stream stream;

  external FT_Module driver;

  @FT_Int()
  external int num_params;

  external ffi.Pointer<FT_Parameter> params;
}

/// @type:
/// FT_Byte
///
/// @description:
/// A simple typedef for the _unsigned_ char type.
typedef FT_Byte = ffi.UnsignedChar;
typedef DartFT_Byte = int;

/// @type:
/// FT_Module
///
/// @description:
/// A handle to a given FreeType module object.  A module can be a font
/// driver, a renderer, or anything else that provides services to the
/// former.
typedef FT_Module = ffi.Pointer<FT_ModuleRec_>;

/// @struct:
/// FT_Parameter
///
/// @description:
/// A simple structure to pass more or less generic parameters to
/// @FT_Open_Face and @FT_Face_Properties.
///
/// @fields:
/// tag ::
/// A four-byte identification tag.
///
/// data ::
/// A pointer to the parameter data.
///
/// @note:
/// The ID and function of parameters are driver-specific.  See section
/// @parameter_tags for more information.
typedef FT_Parameter = FT_Parameter_;

/// @struct:
/// FT_Open_Args
///
/// @description:
/// A structure to indicate how to open a new font file or stream.  A
/// pointer to such a structure can be used as a parameter for the
/// functions @FT_Open_Face and @FT_Attach_Stream.
///
/// @fields:
/// flags ::
/// A set of bit flags indicating how to use the structure.
///
/// memory_base ::
/// The first byte of the file in memory.
///
/// memory_size ::
/// The size in bytes of the file in memory.
///
/// pathname ::
/// A pointer to an 8-bit file pathname, which must be a C~string (i.e.,
/// no null bytes except at the very end).  The pointer is not owned by
/// FreeType.
///
/// stream ::
/// A handle to a source stream object.
///
/// driver ::
/// This field is exclusively used by @FT_Open_Face; it simply specifies
/// the font driver to use for opening the face.  If set to `NULL`,
/// FreeType tries to load the face with each one of the drivers in its
/// list.
///
/// num_params ::
/// The number of extra parameters.
///
/// params ::
/// Extra parameters passed to the font driver when opening a new face.
///
/// @note:
/// The stream type is determined by the contents of `flags`:
///
/// If the @FT_OPEN_MEMORY bit is set, assume that this is a memory file
/// of `memory_size` bytes, located at `memory_address`.  The data are not
/// copied, and the client is responsible for releasing and destroying
/// them _after_ the corresponding call to @FT_Done_Face.
///
/// Otherwise, if the @FT_OPEN_STREAM bit is set, assume that a custom
/// input stream `stream` is used.
///
/// Otherwise, if the @FT_OPEN_PATHNAME bit is set, assume that this is a
/// normal file and use `pathname` to open it.
///
/// If none of the above bits are set or if multiple are set at the same
/// time, the flags are invalid and @FT_Open_Face fails.
///
/// If the @FT_OPEN_DRIVER bit is set, @FT_Open_Face only tries to open
/// the file with the driver whose handler is in `driver`.
///
/// If the @FT_OPEN_PARAMS bit is set, the parameters given by
/// `num_params` and `params` is used.  They are ignored otherwise.
///
/// Ideally, both the `pathname` and `params` fields should be tagged as
/// 'const'; this is missing for API backward compatibility.  In other
/// words, applications should treat them as read-only.
typedef FT_Open_Args = FT_Open_Args_;

/// @enum:
/// FT_Size_Request_Type
///
/// @description:
/// An enumeration type that lists the supported size request types, i.e.,
/// what input size (in font units) maps to the requested output size (in
/// pixels, as computed from the arguments of @FT_Size_Request).
///
/// @values:
/// FT_SIZE_REQUEST_TYPE_NOMINAL ::
/// The nominal size.  The `units_per_EM` field of @FT_FaceRec is used
/// to determine both scaling values.
///
/// This is the standard scaling found in most applications.  In
/// particular, use this size request type for TrueType fonts if they
/// provide optical scaling or something similar.  Note, however, that
/// `units_per_EM` is a rather abstract value which bears no relation to
/// the actual size of the glyphs in a font.
///
/// FT_SIZE_REQUEST_TYPE_REAL_DIM ::
/// The real dimension.  The sum of the `ascender` and (minus of) the
/// `descender` fields of @FT_FaceRec is used to determine both scaling
/// values.
///
/// FT_SIZE_REQUEST_TYPE_BBOX ::
/// The font bounding box.  The width and height of the `bbox` field of
/// @FT_FaceRec are used to determine the horizontal and vertical
/// scaling value, respectively.
///
/// FT_SIZE_REQUEST_TYPE_CELL ::
/// The `max_advance_width` field of @FT_FaceRec is used to determine
/// the horizontal scaling value; the vertical scaling value is
/// determined the same way as @FT_SIZE_REQUEST_TYPE_REAL_DIM does.
/// Finally, both scaling values are set to the smaller one.  This type
/// is useful if you want to specify the font size for, say, a window of
/// a given dimension and 80x24 cells.
///
/// FT_SIZE_REQUEST_TYPE_SCALES ::
/// Specify the scaling values directly.
///
/// @note:
/// The above descriptions only apply to scalable formats.  For bitmap
/// formats, the behaviour is up to the driver.
///
/// See the note section of @FT_Size_Metrics if you wonder how size
/// requesting relates to scaling values.
abstract class FT_Size_Request_Type_ {
  static const int FT_SIZE_REQUEST_TYPE_NOMINAL = 0;
  static const int FT_SIZE_REQUEST_TYPE_REAL_DIM = 1;
  static const int FT_SIZE_REQUEST_TYPE_BBOX = 2;
  static const int FT_SIZE_REQUEST_TYPE_CELL = 3;
  static const int FT_SIZE_REQUEST_TYPE_SCALES = 4;
  static const int FT_SIZE_REQUEST_TYPE_MAX = 5;
}

/// @struct:
/// FT_Size_RequestRec
///
/// @description:
/// A structure to model a size request.
///
/// @fields:
/// type ::
/// See @FT_Size_Request_Type.
///
/// width ::
/// The desired width, given as a 26.6 fractional point value (with 72pt
/// = 1in).
///
/// height ::
/// The desired height, given as a 26.6 fractional point value (with
/// 72pt = 1in).
///
/// horiResolution ::
/// The horizontal resolution (dpi, i.e., pixels per inch).  If set to
/// zero, `width` is treated as a 26.6 fractional **pixel** value, which
/// gets internally rounded to an integer.
///
/// vertResolution ::
/// The vertical resolution (dpi, i.e., pixels per inch).  If set to
/// zero, `height` is treated as a 26.6 fractional **pixel** value,
/// which gets internally rounded to an integer.
///
/// @note:
/// If `width` is zero, the horizontal scaling value is set equal to the
/// vertical scaling value, and vice versa.
///
/// If `type` is `FT_SIZE_REQUEST_TYPE_SCALES`, `width` and `height` are
/// interpreted directly as 16.16 fractional scaling values, without any
/// further modification, and both `horiResolution` and `vertResolution`
/// are ignored.
final class FT_Size_RequestRec_ extends ffi.Struct {
  @ffi.Int32()
  external int type;

  @FT_Long()
  external int width;

  @FT_Long()
  external int height;

  @FT_UInt()
  external int horiResolution;

  @FT_UInt()
  external int vertResolution;
}

/// @struct:
/// FT_Size_Request
///
/// @description:
/// A handle to a size request structure.
typedef FT_Size_Request = ffi.Pointer<FT_Size_RequestRec_>;

/// @type:
/// FT_F26Dot6
///
/// @description:
/// A signed 26.6 fixed-point type used for vectorial pixel coordinates.
typedef FT_F26Dot6 = ffi.Long;
typedef DartFT_F26Dot6 = int;
typedef FT_Int32 = ffi.Int;
typedef DartFT_Int32 = int;

/// @struct:
/// FT_Matrix
///
/// @description:
/// A simple structure used to store a 2x2 matrix.  Coefficients are in
/// 16.16 fixed-point format.  The computation performed is:
///
/// ```
/// x' = x*xx + y*xy
/// y' = x*yx + y*yy
/// ```
///
/// @fields:
/// xx ::
/// Matrix coefficient.
///
/// xy ::
/// Matrix coefficient.
///
/// yx ::
/// Matrix coefficient.
///
/// yy ::
/// Matrix coefficient.
typedef FT_Matrix = FT_Matrix_;

/// @struct:
/// FT_Matrix
///
/// @description:
/// A simple structure used to store a 2x2 matrix.  Coefficients are in
/// 16.16 fixed-point format.  The computation performed is:
///
/// ```
/// x' = x*xx + y*xy
/// y' = x*yx + y*yy
/// ```
///
/// @fields:
/// xx ::
/// Matrix coefficient.
///
/// xy ::
/// Matrix coefficient.
///
/// yx ::
/// Matrix coefficient.
///
/// yy ::
/// Matrix coefficient.
final class FT_Matrix_ extends ffi.Struct {
  @FT_Fixed()
  external int xx;

  @FT_Fixed()
  external int xy;

  @FT_Fixed()
  external int yx;

  @FT_Fixed()
  external int yy;
}

/// @enum:
/// FT_Render_Mode
///
/// @description:
/// Render modes supported by FreeType~2.  Each mode corresponds to a
/// specific type of scanline conversion performed on the outline.
///
/// For bitmap fonts and embedded bitmaps the `bitmap->pixel_mode` field
/// in the @FT_GlyphSlotRec structure gives the format of the returned
/// bitmap.
///
/// All modes except @FT_RENDER_MODE_MONO use 256 levels of opacity,
/// indicating pixel coverage.  Use linear alpha blending and gamma
/// correction to correctly render non-monochrome glyph bitmaps onto a
/// surface; see @FT_Render_Glyph.
///
/// The @FT_RENDER_MODE_SDF is a special render mode that uses up to 256
/// distance values, indicating the signed distance from the grid position
/// to the nearest outline.
///
/// @values:
/// FT_RENDER_MODE_NORMAL ::
/// Default render mode; it corresponds to 8-bit anti-aliased bitmaps.
///
/// FT_RENDER_MODE_LIGHT ::
/// This is equivalent to @FT_RENDER_MODE_NORMAL.  It is only defined as
/// a separate value because render modes are also used indirectly to
/// define hinting algorithm selectors.  See @FT_LOAD_TARGET_XXX for
/// details.
///
/// FT_RENDER_MODE_MONO ::
/// This mode corresponds to 1-bit bitmaps (with 2~levels of opacity).
///
/// FT_RENDER_MODE_LCD ::
/// This mode corresponds to horizontal RGB and BGR subpixel displays
/// like LCD screens.  It produces 8-bit bitmaps that are 3~times the
/// width of the original glyph outline in pixels, and which use the
/// @FT_PIXEL_MODE_LCD mode.
///
/// FT_RENDER_MODE_LCD_V ::
/// This mode corresponds to vertical RGB and BGR subpixel displays
/// (like PDA screens, rotated LCD displays, etc.).  It produces 8-bit
/// bitmaps that are 3~times the height of the original glyph outline in
/// pixels and use the @FT_PIXEL_MODE_LCD_V mode.
///
/// FT_RENDER_MODE_SDF ::
/// This mode corresponds to 8-bit, single-channel signed distance field
/// (SDF) bitmaps.  Each pixel in the SDF grid is the value from the
/// pixel's position to the nearest glyph's outline.  The distances are
/// calculated from the center of the pixel and are positive if they are
/// filled by the outline (i.e., inside the outline) and negative
/// otherwise.  Check the note below on how to convert the output values
/// to usable data.
///
/// @note:
/// The selected render mode only affects vector glyphs of a font.
/// Embedded bitmaps often have a different pixel mode like
/// @FT_PIXEL_MODE_MONO.  You can use @FT_Bitmap_Convert to transform them
/// into 8-bit pixmaps.
///
/// For @FT_RENDER_MODE_SDF the output bitmap buffer contains normalized
/// distances that are packed into unsigned 8-bit values.  To get pixel
/// values in floating point representation use the following pseudo-C
/// code for the conversion.
///
/// ```
/// // Load glyph and render using FT_RENDER_MODE_SDF,
/// // then use the output buffer as follows.
///
/// ...
/// FT_Byte  buffer = glyph->bitmap->buffer;
///
///
/// for pixel in buffer
/// {
/// // `sd` is the signed distance and `spread` is the current spread;
/// // the default spread is 2 and can be changed.
///
/// float  sd = (float)pixel - 128.0f;
///
///
/// // Convert to pixel values.
/// sd = ( sd / 128.0f ) * spread;
///
/// // Store `sd` in a buffer or use as required.
/// }
///
/// ```
///
/// FreeType has two rasterizers for generating SDF, namely:
///
/// 1. `sdf` for generating SDF directly from glyph's outline, and
///
/// 2. `bsdf` for generating SDF from rasterized bitmaps.
///
/// Depending on the glyph type (i.e., outline or bitmap), one of the two
/// rasterizers is chosen at runtime and used for generating SDFs.  To
/// force the use of `bsdf` you should render the glyph with any of the
/// FreeType's other rendering modes (e.g., `FT_RENDER_MODE_NORMAL`) and
/// then re-render with `FT_RENDER_MODE_SDF`.
///
/// There are some issues with stability and possible failures of the SDF
/// renderers (specifically `sdf`).
///
/// 1. The `sdf` rasterizer is sensitive to really small features (e.g.,
/// sharp turns that are less than 1~pixel) and imperfections in the
/// glyph's outline, causing artifacts in the final output.
///
/// 2. The `sdf` rasterizer has limited support for handling intersecting
/// contours and *cannot* handle self-intersecting contours whatsoever.
/// Self-intersection happens when a single connected contour
/// intersects itself at some point; having these in your font
/// definitely poses a problem to the rasterizer and cause artifacts,
/// too.
///
/// 3. Generating SDF for really small glyphs may result in undesirable
/// output; the pixel grid (which stores distance information) becomes
/// too coarse.
///
/// 4. Since the output buffer is normalized, precision at smaller spreads
/// is greater than precision at larger spread values because the
/// output range of [0..255] gets mapped to a smaller SDF range.  A
/// spread of~2 should be sufficient in most cases.
///
/// Points (1) and (2) can be avoided by using the `bsdf` rasterizer,
/// which is more stable than the `sdf` rasterizer in general.
abstract class FT_Render_Mode_ {
  static const int FT_RENDER_MODE_NORMAL = 0;
  static const int FT_RENDER_MODE_LIGHT = 1;
  static const int FT_RENDER_MODE_MONO = 2;
  static const int FT_RENDER_MODE_LCD = 3;
  static const int FT_RENDER_MODE_LCD_V = 4;
  static const int FT_RENDER_MODE_SDF = 5;
  static const int FT_RENDER_MODE_MAX = 6;
}

/// @enum:
/// FT_Kerning_Mode
///
/// @description:
/// An enumeration to specify the format of kerning values returned by
/// @FT_Get_Kerning.
///
/// @values:
/// FT_KERNING_DEFAULT ::
/// Return grid-fitted kerning distances in 26.6 fractional pixels.
///
/// FT_KERNING_UNFITTED ::
/// Return un-grid-fitted kerning distances in 26.6 fractional pixels.
///
/// FT_KERNING_UNSCALED ::
/// Return the kerning vector in original font units.
///
/// @note:
/// `FT_KERNING_DEFAULT` returns full pixel values; it also makes FreeType
/// heuristically scale down kerning distances at small ppem values so
/// that they don't become too big.
///
/// Both `FT_KERNING_DEFAULT` and `FT_KERNING_UNFITTED` use the current
/// horizontal scaling factor (as set e.g. with @FT_Set_Char_Size) to
/// convert font units to pixels.
abstract class FT_Kerning_Mode_ {
  static const int FT_KERNING_DEFAULT = 0;
  static const int FT_KERNING_UNFITTED = 1;
  static const int FT_KERNING_UNSCALED = 2;
}

typedef FT_UInt32 = ffi.UnsignedInt;
typedef DartFT_UInt32 = int;

/// @type:
/// FT_Bool
///
/// @description:
/// A typedef of unsigned char, used for simple booleans.  As usual,
/// values 1 and~0 represent true and false, respectively.
typedef FT_Bool = ffi.UnsignedChar;
typedef DartFT_Bool = int;

const int ft_encoding_none = 0;

const int ft_encoding_unicode = 1970170211;

const int ft_encoding_symbol = 1937337698;

const int ft_encoding_latin_1 = 1818326065;

const int ft_encoding_latin_2 = 1818326066;

const int ft_encoding_sjis = 1936353651;

const int ft_encoding_gb2312 = 1734484000;

const int ft_encoding_big5 = 1651074869;

const int ft_encoding_wansung = 2002873971;

const int ft_encoding_johab = 1785686113;

const int ft_encoding_adobe_standard = 1094995778;

const int ft_encoding_adobe_expert = 1094992453;

const int ft_encoding_adobe_custom = 1094992451;

const int ft_encoding_apple_roman = 1634889070;

const int FT_FACE_FLAG_SCALABLE = 1;

const int FT_FACE_FLAG_FIXED_SIZES = 2;

const int FT_FACE_FLAG_FIXED_WIDTH = 4;

const int FT_FACE_FLAG_SFNT = 8;

const int FT_FACE_FLAG_HORIZONTAL = 16;

const int FT_FACE_FLAG_VERTICAL = 32;

const int FT_FACE_FLAG_KERNING = 64;

const int FT_FACE_FLAG_FAST_GLYPHS = 128;

const int FT_FACE_FLAG_MULTIPLE_MASTERS = 256;

const int FT_FACE_FLAG_GLYPH_NAMES = 512;

const int FT_FACE_FLAG_EXTERNAL_STREAM = 1024;

const int FT_FACE_FLAG_HINTER = 2048;

const int FT_FACE_FLAG_CID_KEYED = 4096;

const int FT_FACE_FLAG_TRICKY = 8192;

const int FT_FACE_FLAG_COLOR = 16384;

const int FT_FACE_FLAG_VARIATION = 32768;

const int FT_FACE_FLAG_SVG = 65536;

const int FT_FACE_FLAG_SBIX = 131072;

const int FT_FACE_FLAG_SBIX_OVERLAY = 262144;

const int FT_STYLE_FLAG_ITALIC = 1;

const int FT_STYLE_FLAG_BOLD = 2;

const int FT_OPEN_MEMORY = 1;

const int FT_OPEN_STREAM = 2;

const int FT_OPEN_PATHNAME = 4;

const int FT_OPEN_DRIVER = 8;

const int FT_OPEN_PARAMS = 16;

const int ft_open_memory = 1;

const int ft_open_stream = 2;

const int ft_open_pathname = 4;

const int ft_open_driver = 8;

const int ft_open_params = 16;

const int FT_LOAD_DEFAULT = 0;

const int FT_LOAD_NO_SCALE = 1;

const int FT_LOAD_NO_HINTING = 2;

const int FT_LOAD_RENDER = 4;

const int FT_LOAD_NO_BITMAP = 8;

const int FT_LOAD_VERTICAL_LAYOUT = 16;

const int FT_LOAD_FORCE_AUTOHINT = 32;

const int FT_LOAD_CROP_BITMAP = 64;

const int FT_LOAD_PEDANTIC = 128;

const int FT_LOAD_IGNORE_GLOBAL_ADVANCE_WIDTH = 512;

const int FT_LOAD_NO_RECURSE = 1024;

const int FT_LOAD_IGNORE_TRANSFORM = 2048;

const int FT_LOAD_MONOCHROME = 4096;

const int FT_LOAD_LINEAR_DESIGN = 8192;

const int FT_LOAD_SBITS_ONLY = 16384;

const int FT_LOAD_NO_AUTOHINT = 32768;

const int FT_LOAD_COLOR = 1048576;

const int FT_LOAD_COMPUTE_METRICS = 2097152;

const int FT_LOAD_BITMAP_METRICS_ONLY = 4194304;

const int FT_LOAD_NO_SVG = 16777216;

const int FT_LOAD_ADVANCE_ONLY = 256;

const int FT_LOAD_SVG_ONLY = 8388608;

const int FT_LOAD_TARGET_NORMAL = 0;

const int FT_LOAD_TARGET_LIGHT = 65536;

const int FT_LOAD_TARGET_MONO = 131072;

const int FT_LOAD_TARGET_LCD = 196608;

const int FT_LOAD_TARGET_LCD_V = 262144;

const int ft_render_mode_normal = 0;

const int ft_render_mode_mono = 2;

const int ft_kerning_default = 0;

const int ft_kerning_unfitted = 1;

const int ft_kerning_unscaled = 2;

const int FT_SUBGLYPH_FLAG_ARGS_ARE_WORDS = 1;

const int FT_SUBGLYPH_FLAG_ARGS_ARE_XY_VALUES = 2;

const int FT_SUBGLYPH_FLAG_ROUND_XY_TO_GRID = 4;

const int FT_SUBGLYPH_FLAG_SCALE = 8;

const int FT_SUBGLYPH_FLAG_XY_SCALE = 64;

const int FT_SUBGLYPH_FLAG_2X2 = 128;

const int FT_SUBGLYPH_FLAG_USE_MY_METRICS = 512;

const int FT_FSTYPE_INSTALLABLE_EMBEDDING = 0;

const int FT_FSTYPE_RESTRICTED_LICENSE_EMBEDDING = 2;

const int FT_FSTYPE_PREVIEW_AND_PRINT_EMBEDDING = 4;

const int FT_FSTYPE_EDITABLE_EMBEDDING = 8;

const int FT_FSTYPE_NO_SUBSETTING = 256;

const int FT_FSTYPE_BITMAP_EMBEDDING_ONLY = 512;

const int FREETYPE_MAJOR = 2;

const int FREETYPE_MINOR = 13;

const int FREETYPE_PATCH = 2;
